#!/usr/bin/env node
/* eslint-disable global-require */
const { resolve: resolvePath } = require('path')
const { info, warn, error } = require('ara-console')
const { DIDDocument } = require('did-document')
const isDomainName = require('is-domain-name')
const { table } = require('table')
const inquirer = require('inquirer')
const program = require('yargs')
const debug = require('debug')('ara:identity')
const pify = require('pify')
const did = require('did-uri')
const ram = require('random-access-memory')
const rc = require('../rc')()
const ss = require('ara-secret-storage')
const fs = require('fs')
const ip = require('ip')

process.on('unhandledRejection', onfatal)
process.on('uncaughtException', onfatal)

const ellipsis = (s, x, y) => s.slice(x || 0, y || 4)

program
  .usage('usage: $0 [-hqDV] <command> [options]')
  .wrap(null)

program
  .group([ 'help', 'quiet', 'debug', 'version' ], 'General Options:')
  .option('help', {
    alias: 'h',
    describe: 'Show this help message',
  })
  .option('quiet', {
    alias: 'q',
    describe: 'Only output errors and results'
  })
  .option('debug', {
    alias: 'D',
    describe: 'Enable debug output',
  })
  .option('version', {
    alias: 'V',
    describe: 'Show program version'
  })

// global checks
program.check((argv) => {
  if (undefined !== argv.encoding) {
    if (false === Buffer.isEncoding(argv.encoding)) {
      throw new TypeError(`${argv.encoding} is not a valid encoding type.`)
    }
  }

  return true
})

program.command(
  'create',
  'Create an identity',
  // eslint-disable-next-line no-shadow
  program => program
    .usage('usage: $0 create [-D] [options]')
  , oncreate
)

program.command(
  'archive',
  'Archive identity in network',
  // eslint-disable-next-line no-shadow
  program => program
    .usage('usage: $0 archive [-D] [options] [identifier]')
    .positional('identifier', {
      default:
        rc.network.identity.archiver.whoami ||
        rc.network.identity.whoami ||
        rc.network.whoami,
    })
    .group([ 'secret', 'keyring', 'network' ], 'Network Options:')
    .option('secret', {
      alias: 's',
      describe: 'Shared secret key for the associated network keys',
      required: true,
      requiresArg: true,
      default:
        rc.network.identity.archiver.secret ||
        rc.network.identity.secret ||
        rc.network.secret
    })
    .option('keyring', {
      alias: 'k',
      describe: 'Path to Ara network keyring file',
      required: true,
      requiresArg: true,
      default:
        rc.network.identity.archiver.keyring ||
        rc.network.identity.keyring ||
        rc.network.keyring,
    })
    .option('network', {
      alias: 'n',
      describe: 'Human readable network name for keys in keyring',
      required: true,
      requiresArg: true,
      default: rc.network.identity.archiver.network,
    })
    .option('max-connections', {
      describe: 'Maximum number of Archivers to find',
      required: true,
      requiresArg: true,
      default: 32,
    })
    .option('shallow', {
      type: 'boolean',
      default: false,
      describe: 'Only archive the ddo',
      requiresArg: false,
    })
  , onarchive
)

program.command(
  'resolve',
  'Resolve an identity from the network, disk, or cache',
  // eslint-disable-next-line no-shadow
  program => program
    .usage('usage: $0 resolve [-D] [options] [identifier]')
    .positional('identifier', {
      default:
        rc.network.identity.resolver.whoami ||
        rc.network.identity.whoami ||
        rc.network.whoami,
    })

    .group([ 'peers', 'proof', 'short', 'stats' ], 'Output Options:')
    .option('peers', {
      describe: 'Find and output peers broadcasting this identity.',
      requiresArg: false,
      type: 'boolean',
    })
    .option('proof', {
      describe: 'Output just the DID proof from the resolution result.',
      requiresArg: false,
      type: 'boolean',
    })
    .option('short', {
      describe: 'Output just the DID ID from the resolution result.',
      requiresArg: false,
      type: 'boolean',
    })
    .option('stats', {
      describe: 'Output just the DID stats from the resolution result.',
      requiresArg: false,
      type: 'boolean',
    })

    .group([ 'secret', 'keyring', 'network' ], 'Network Options:')
    .option('secret', {
      alias: 's',
      describe: 'Shared secret key for the associated network keys.',
      requiresArg: true,
      default:
        rc.network.identity.resolver.secret ||
        rc.network.identity.secret ||
        rc.network.secret
    })
    .option('network', {
      alias: 'n',
      describe: 'Human readable network name for keys in keyring',
      requiresArg: true,
      default: rc.network.identity.resolver.network,
    })
    .option('keyring', {
      alias: 'k',
      describe: 'Path to Ara network keyring file',
      requiresArg: true,
      default:
        rc.network.identity.resolver.keyring ||
        rc.network.identity.keyring ||
        rc.network.keyring,
    })

    .group([ 'cache', 'timeout' ], 'Resolution Options:')
    .option('cache', {
      type: 'boolean',
      describe: 'Enable or disable cache',
      default: true,
    })
    .option('timeout', {
      describe: 'Resolution timeout',
    })
  , onresolve
)

program.command(
  'list',
  'Output local identity identifiers',
  // eslint-disable-next-line no-shadow
  program => program
    .usage('usage: $0 list [-D] [options]')
    .group([ 'path' ], 'List Options:')
    .option('path', {
      alias: 'p',
      describe: 'Path to look for identities',
      optional: true
    })
  , onlist
)

program.command(
  'whoami',
  'Output current Ara identity in context (.ararc)',
  // eslint-disable-next-line no-shadow
  program => program
    .usage('usage: $0 whoami [-D] [options]')
    .group([ 'secret', 'keyring', 'network' ], 'Network Options:')
    .option('secret', {
      alias: 's',
      describe: 'Shared secret key for the associated network keys.',
      requiresArg: true,
      default:
        rc.network.identity.resolver.secret ||
        rc.network.identity.secret ||
        rc.network.secret
    })
    .option('network', {
      alias: 'n',
      describe: 'Human readable network name for keys in keyring',
      requiresArg: true,
      default: rc.network.identity.resolver.network,
    })
    .option('keyring', {
      alias: 'k',
      describe: 'Path to Ara network keyring file',
      requiresArg: true,
      default:
        rc.network.identity.resolver.keyring ||
        rc.network.identity.keyring ||
        rc.network.keyring,
    })
    .group([ 'cache', 'fast', 'timeout' ], 'Resolution Options:')
    .option('cache', {
      type: 'boolean',
      describe: 'Enable or disable cache',
      default: true,
    })
    .option('fast', {
      type: 'boolean',
      describe: 'Use fastest possible resolution.',
    })
    .option('timeout', {
      describe: 'Resolution timeout',
    })
  , onwhoami
)

program.command(
  'recover',
  'Recover an identity using a mnemonic phrase',
  // eslint-disable-next-line no-shadow
  program => program
    .usage('usage: $0 [-D] recover [options]')
    .group([ 'mnemonic' ], 'Recovery Options:')
    .option('mnemonic', {
      alias: 'm',
      describe: 'Valid bip39 mnemonic',
      required: true,
      requiresArg: true,
    })
  , onrecover
)

program.command(
  'revoke',
  'Revoke an identity using a mnemonic phrase',
  // eslint-disable-next-line no-shadow
  program => program
    .usage('usage: $0 [-D] revoke [options]')
    .group([ 'mnemonic' ], 'Revoke Options:')
    .option('mnemonic', {
      alias: 'm',
      describe: 'Valid bip39 mnemonic',
      required: true,
      requiresArg: true,
    })
  , onrevoke
)

program.command(
  'keystore-dump',
  'Dump secret keys and secret storages to stdout',
  // eslint-disable-next-line no-shadow
  program => program
    .usage('usage: $0 keystore-dump [-D] [options] [identifier]')
    .positional('identifier', {
      default: rc.network.identity.whoami || rc.network.whoami,
    })

    .group([ 'secret-storage', 'path', 'type' ], 'Options:')
    .option('secret-storage', {
      alias: 'S',
      type: 'boolean',
      default: false,
      optional: true,
      describe: 'Set true if secret storage needs to be retrieved'
    })
    .option('path', {
      alias: 'p',
      optional: true,
      describe: 'Path to look for did directory'
    })
    .option('type', {
      alias: 't',
      default: 'eth',
    })
  , onkeystoredump
)

program.command(
  'add-public-key',
  'Add a public key to an identity',
  // eslint-disable-next-line no-shadow
  program => program
    .usage('usage: $0 add-public-key [-D] [options] [identifier]')
    .group([ 'key' ], 'Public Key Options:')
    .positional('identifier', {
      default: rc.network.identity.whoami || rc.network.whoami,
      required: true,
      type: String
    })
    .option('key', {
      describe: 'JSON of public key to import to the `publicKey` section of the DDO',
      required: true
    })
  , onaddpublickey
)

program.command(
  'remove-public-key',
  'Remove a public key from an identity',
  // eslint-disable-next-line no-shadow
  program => program
    .usage('usage: $0 remove-public-key [-D] [options] [identifier]')
    .group([ 'key' ], 'Public Key Removal Options:')
    .positional('identifier', {
      default: rc.network.identity.whoami || rc.network.whoami,
      required: true,
      type: String
    })
    .option('key', {
      describe: 'Fragment name of public key found in identity DDO',
      required: true
    })
  , onremovepublickey
)

program.command(
  'export-public-key',
  'Export a public key from an identity',
  // eslint-disable-next-line no-shadow
  program => program
    .usage('usage: $0 remove-public-key [-D] [options] [identifier]')
    .group([ 'key' ], 'Public Key Export Options:')
    .positional('identifier', {
      default: rc.network.identity.whoami || rc.network.whoami,
      required: true,
      type: String
    })
    .option('key', {
      describe: 'Fragment name of public key found in identity DDO',
      required: true
    })
  , onexportpublickey
)

program.command(
  'add-service',
  'Add a service endpoint to an identity',
  // eslint-disable-next-line no-shadow
  program => program
    .usage('usage: $0 add-service [-D] [options] [identifier]')
    .group([ 'id', 'type', 'endpoint', 'config' ], 'Service Options:')
    .positional('identifier', {
      default: rc.network.identity.whoami || rc.network.whoami,
      required: true,
      type: String
    })
    .option('id', {
      describe: 'ID of service',
      required: true
    })
    .option('type', {
      describe: 'Type of service',
      required: true
    })
    .option('endpoint', {
      describe: 'of the service',
      required: true
    })
    .option('config', {
      describe: 'Path to JSON configuration for the service'
    })
  , onaddservice
)

program.command(
  'remove-service',
  'Remove a service endpoint to an identity',
  // eslint-disable-next-line no-shadow
  program => program
    .usage('usage: $0 remove-service [-D] [options] [identifier]')
    .group([ 'id' ], 'Service Removal Options:')
    .positional('identifier', {
      default: rc.network.identity.whoami || rc.network.whoami,
      required: true,
      type: String
    })
    .option('id', {
      describe: 'ID of service',
      required: true
    })
  , onremoveservice
)

program.command(
  'export-service',
  'Export a service endpoint from an identity',
  // eslint-disable-next-line no-shadow
  program => program
    .usage('usage: $0 export-service [-D] [options] [identifier]')
    .group([ 'endpoint' ], 'Service Export Options:')
    .positional('identifier', {
      default: rc.network.identity.whoami || rc.network.whoami,
      required: true,
      type: String
    })
    .option('id', {
      describe: 'ID of service',
      required: true
    })
  , onexportservice
)

program.command(
  'sign',
  'Sign a message using the secret key for an identity',
  // eslint-disable-next-line no-shadow
  program => program
    .usage('usage: $0 sign [-D] [options] [identifier]')
    .positional('identifier', {
      default: rc.network.identity.whoami || rc.network.whoami,
      required: true,
      type: String
    })

    .group([ 'message' ], 'Signature Options:')
    .option('message', {
      type: String,
      required: true,
      requiresArg: true,
    })

    .group([ 'binary', 'encoding' ], 'Output Options:')
    .option('binary', {
      describe: 'Write signature as binary to stdout.',
      type: 'boolean'
    })
    .option('encoding', {
      alias: 'e',
      default: 'hex',
      describe: 'Signature encoding output format',
      requiresArg: true,
    })

    .group([ 'secret', 'keyring', 'network' ], 'Network Options:')
    .option('secret', {
      alias: 's',
      describe: 'Shared secret key for the associated network keys.',
      requiresArg: true,
      default:
        rc.network.identity.resolver.secret ||
        rc.network.identity.secret ||
        rc.network.secret
    })
    .option('network', {
      alias: 'n',
      describe: 'Human readable network name for keys in keyring',
      requiresArg: true,
      default: rc.network.identity.resolver.network,
    })
    .option('keyring', {
      alias: 'k',
      describe: 'Path to Ara network keyring file',
      requiresArg: true,
      default:
        rc.network.identity.resolver.keyring ||
        rc.network.identity.keyring ||
        rc.network.keyring,
    })

    .group([ 'cache', 'timeout' ], 'Resolution Options:')
    .option('cache', {
      type: 'boolean',
      describe: 'Enable or disable cache',
      default: true,
    })
    .option('timeout', {
      describe: 'Resolution timeout',
    })
  , onsign
)

program.command(
  'verify',
  'Verify a message using the public key for an identity',
  // eslint-disable-next-line no-shadow
  program => program
    .usage('usage: $0 verify [-D] [options] [identifier]')
    .positional('identifier', {
      default: rc.network.identity.whoami || rc.network.whoami,
      required: true,
      type: String
    })

    .group([ 'message', 'signature', 'encoding' ], 'Verification Options:')
    .option('message', {
      type: String,
      required: true,
      requiresArg: true,
    })
    .option('signature', {
      type: String,
      required: true,
      requiresArg: true,
    })
    .option('encoding', {
      alias: 'e',
      default: 'hex',
      describe: 'Signature encoding input format',
      requiresArg: true,
    })

    .group([ 'secret', 'keyring', 'network' ], 'Network Options:')
    .option('secret', {
      alias: 's',
      describe: 'Shared secret key for the associated network keys.',
      requiresArg: true,
      default:
        rc.network.identity.resolver.secret ||
        rc.network.identity.secret ||
        rc.network.secret
    })
    .option('network', {
      alias: 'n',
      describe: 'Human readable network name for keys in keyring',
      requiresArg: true,
      default: rc.network.identity.resolver.network,
    })
    .option('keyring', {
      alias: 'k',
      describe: 'Path to Ara network keyring file',
      requiresArg: true,
      default:
        rc.network.identity.resolver.keyring ||
        rc.network.identity.keyring ||
        rc.network.keyring,
    })

    .group([ 'cache', 'timeout' ], 'Resolution Options:')
    .option('cache', {
      type: 'boolean',
      describe: 'Enable or disable cache',
      default: true,
    })
    .option('timeout', {
      describe: 'Resolution timeout',
    })
  , onverify
)

program.command(
  'bind-dns',
  'Bind a domain name to an identity',
  // eslint-disable-next-line no-shadow
  program => program
    .usage('usage: $0 bind-dns [-D] [options] [identifier]')
    .group([ 'domain', 'type' ], 'Bind Options:')
    .positional('identifier', {
      default: rc.network.identity.whoami || rc.network.whoami,
      required: true,
      type: String
    })
    .option('domain', {
      describe: 'Domain name',
      required: true
    })
    .option('type', {
      describe: 'Domain name record type',
      default: 'TXT',
      required: true
    })

    .group([ 'secret', 'keyring', 'network' ], 'Network Options:')
    .option('secret', {
      alias: 's',
      describe: 'Shared secret key for the associated network keys.',
      requiresArg: true,
      default:
        rc.network.identity.resolver.secret ||
        rc.network.identity.secret ||
        rc.network.secret
    })
    .option('network', {
      alias: 'n',
      describe: 'Human readable network name for keys in keyring',
      requiresArg: true,
      default: rc.network.identity.resolver.network,
    })
    .option('keyring', {
      alias: 'k',
      describe: 'Path to Ara network keyring file',
      requiresArg: true,
      default:
        rc.network.identity.resolver.keyring ||
        rc.network.identity.keyring ||
        rc.network.keyring,
    })

    .group([ 'cache', 'timeout' ], 'Resolution Options:')
    .option('cache', {
      type: 'boolean',
      describe: 'Enable or disable cache',
      default: true,
    })
    .option('timeout', {
      describe: 'Resolution timeout',
    })
  , onbinddns
)

program.command(
  'unbind-dns',
  'Unbind a domain name from an identity',
  // eslint-disable-next-line no-shadow
  program => program
    .usage('usage: $0 unbind-dns [-D] [options] [identifier]')
    .group([ 'domain', 'type' ], 'Unbind Options:')
    .positional('identifier', {
      default: rc.network.identity.whoami || rc.network.whoami,
      required: true,
      type: String
    })
    .option('domain', {
      describe: 'Domain name',
      required: true
    })

    .group([ 'secret', 'keyring', 'network' ], 'Network Options:')
    .option('secret', {
      alias: 's',
      describe: 'Shared secret key for the associated network keys.',
      requiresArg: true,
      default:
        rc.network.identity.resolver.secret ||
        rc.network.identity.secret ||
        rc.network.secret
    })
    .option('network', {
      alias: 'n',
      describe: 'Human readable network name for keys in keyring',
      requiresArg: true,
      default: rc.network.identity.resolver.network,
    })
    .option('keyring', {
      alias: 'k',
      describe: 'Path to Ara network keyring file',
      requiresArg: true,
      default:
        rc.network.identity.resolver.keyring ||
        rc.network.identity.keyring ||
        rc.network.keyring,
    })

    .group([ 'cache', 'timeout' ], 'Resolution Options:')
    .option('cache', {
      type: 'boolean',
      describe: 'Enable or disable cache',
      default: true,
    })
    .option('timeout', {
      describe: 'Resolution timeout',
    })
  , onunbinddns
)

program
  .recommendCommands()
  .demandCommand()
  .completion('__completions', false)

void program.getOptions().boolean.splice(-2)

try {
  if (0 === program.argv._.length) {
    program.showHelp()
    exit(1)
  }
} catch (err) {
  debug(err)
  exit(1)
}

if (program.argv.debug) {
  // eslint-disable-next-line global-require
  require('debug').enable('ara:identity*')
}

async function onrecover(argv) {
  const aid = require('../')

  const { mnemonic } = argv
  let { password } = argv

  if ('string' === typeof password) {
    try {
      await pify(fs.access)(password)
      password = String(await pify(fs.readFile)(password))
    } catch (err) {
      void err
    }
  }

  if (!password) {
    ({ password } = await inquirer.prompt([ {
      type: 'password',
      name: 'password',
      message:
      'Your identity\'s keystore will be secured by a passphrase ' +
      'after recovery. \n' +
      'Please provide a passphrase. Do not forget this as it will never be ' +
      'shown to you.\n' +
      'Passphrase:'
    } ]))
  }

  if (!password) {
    // eslint-disable-next-line function-paren-newline
    return onfatal(
      new TypeError('A new passphrase is required to recover the identity.'))
  }

  try {
    const identity = await aid.recover({ password, mnemonic })
    info('Identity recovered : %s', identity.did)

    for (let i = 0; i < identity.files.length; ++i) {
      warn('Will write identity file: %s', identity.files[i].path)
    }

    await aid.save(identity)
    info('Identity recovered successfully.')
  } catch (err) {
    return onfatal(err)
  }

  return exit(0)
}

async function onrevoke(argv) {
  const aid = require('../')

  const { mnemonic } = argv
  let { password } = argv

  if (!password) {
    ({ password } = await inquirer.prompt([ {
      type: 'password',
      name: 'password',
      message:
      'Please provide a passphrase. Do not forget this as it will never be ' +
      'shown to you and will be required to archive your identity after revoking.\n' +
      'Passphrase:'
    } ]))
  }

  if (!password) {
    // eslint-disable-next-line function-paren-newline
    return onfatal(
      new TypeError('A passphrase is required to revoke your identity.'))
  }

  try {
    const identity = await aid.revoke({ password, mnemonic })
    info('Identity to be revoked : %s', identity.did)

    for (let i = 0; i < identity.files.length; ++i) {
      warn('Will write identity file: %s', identity.files[i].path)
    }

    await aid.save(identity)
    info('Identity revoked successfully.')
  } catch (err) {
    return onfatal(err)
  }

  return exit(0)
}

async function onarchive(argv) {
  const { toHex } = require('../util')
  const protobuf = require('../protobuf')
  const crypto = require('ara-crypto')
  const aid = require('../')

  let { password } = argv

  if ('string' === typeof password) {
    try {
      await pify(fs.access)(password)
      password = await pify(fs.readFile)(password, 'utf8')
    } catch (err) {
      void err
    }
  }

  if (!password) {
    ({ password } = await inquirer.prompt([ {
      type: 'password',
      name: 'password',
      message:
      'Please provide a passphrase for your identity. This is needed to ' +
      'archive your identity.\n' +
      'Passphrase:'
    } ]))
  }

  if (!password) {
    // eslint-disable-next-line function-paren-newline
    return onfatal(
      new TypeError('Please provide a password to archive your identity.'))
  }

  password = crypto.blake2b(Buffer.from(password))

  const ddo = await aid.resolve(argv.identifier, argv)
  const { identifier } = did.parse(ddo.id)
  const stats = {
    totalConnections: 0,
    totalBlocks: 0,
    totalFiles: 0,
  }

  const maxConnections = argv['max-connections']
  const {
    keyring,
    network,
    secret,
    shallow
  } = argv

  let identityBuffer = null
  let didArchive = false
  let secretKey = null
  let publicKey = null
  let identity = null

  try {
    const keystoreBuffer = await aid.fs.readFile(identifier, 'keystore/ara')
    const keystore = JSON.parse(String(keystoreBuffer))

    try {
      secretKey = ss.decrypt(keystore, { key: password.slice(0, 16) })
      publicKey = secretKey.slice(32)
    } catch (err) {
      debug(err)
      return onfatal(new Error('Invalid passphrase when decoding keystore.'))
    }

    identityBuffer = await aid.fs.readFile(identifier, 'identity', argv)
  } catch (err) {
    error('Unable to read identity.')
    return onfatal(err)
  }

  try {
    identity = protobuf.messages.Identity.decode(identityBuffer)
  } catch (err) {
    error('Failed to decode identity.')
    return onfatal(err)
  }

  const { files } = identity

  try {
    // manually construct identity file for archiver
    files.push({
      path: 'identity',
      buffer: identityBuffer
    })

    warn('Archiving new identity for network \'%s\'.', keyring)
    didArchive = await aid.archive({
      publicKey,
      secretKey,
      files
    }, {
      network,
      secret,
      keyring,
      maxConnections,
      shallow,

      onhello,
      onauth,
      onokay,

      onupload,
      onclose,
      onerror,
    })

    info(
      '%d connection%s made',
      stats.totalConnections,
      1 === stats.totalConnections ? '' : 's',
    )

    info(
      '%d block%s uploaded',
      stats.totalBlocks,
      1 === stats.totalBlocks ? '' : 's',
    )

    info(
      '%d file%s uploaded',
      stats.totalFiles,
      1 === stats.totalFiles ? '' : 's',
    )
  } catch (err) {
    error('Failed to archive identity.')
    return onfatal(err)
  }

  if (didArchive) {
    info('Successfully archived identity to network "%s"', network)
    return exit(0)
  }

  error('Failed to archive identity')
  return exit(1)

  function onhello(hello) {
    info(
      'Got hello from archiver node: key=%s mac=%s',
      toHex(ellipsis(hello.publicKey)),
      toHex(ellipsis(hello.mac)),
    )
  }

  function onauth(auth) {
    info(
      'Authenticated with archiver node: key=%s signature=%s',
      toHex(ellipsis(auth.publicKey)),
      toHex(ellipsis(auth.signature)),
    )
  }

  function onokay(okay) {
    info(
      'Got okay from archiver node: signature=%s',
      toHex(ellipsis(okay)),
    )
  }

  function onclose(rinfo) {
    stats.totalConnections = rinfo.totalConnections
    debug(
      'Connection #%d to %s:%s@%s closed.',
      rinfo.peerIndex,
      rinfo.peer.host,
      rinfo.peer.port,
      toHex(ellipsis(rinfo.discoveryKey)),
    )
  }

  function onupload(rinfo) {
    stats.totalBlocks = rinfo.blocks
    stats.totalFiles = rinfo.writes
  }

  function onerror(err) {
    debug(err.stack || err)
    error('Got error in archiver:', err.message)
  }
}

async function oncreate(argv) {
  const aid = require('../')

  let { password } = argv

  if ('string' === typeof password) {
    try {
      await pify(fs.access)(password)
      password = String(await pify(fs.readFile)(password))
    } catch (err) {
      void err
    }
  }

  if (!password) {
    ({ password } = await inquirer.prompt([ {
      type: 'password',
      name: 'password',
      message:
      'Your identity\'s keystore will be secured by a passphrase. \n' +
      'Please provide a passphrase. Do not forget this as it will never be ' +
      'shown to you.\n' +
      'Passphrase:'
    } ]))
  }

  if (!password) {
    // eslint-disable-next-line function-paren-newline
    return onfatal(
      new TypeError('A new passphrase is required to secure the identity.'))
  }

  if (!argv.quiet) { process.stdout.write('\n') }

  const identity = await aid.create({ password })

  if (!argv.quiet) { info('New identity created: %s', identity.did) }

  if (!argv.quiet) {
    for (let i = 0; i < identity.files.length; ++i) {
      warn('Will write identity file: %s', identity.files[i].path)
    }
  }

  await aid.save(identity)

  if (!argv.quiet) {
    info('Please safely store the following 12 word mnemonic phrase for this')
    info('Ara ID. This phrase will be required to restore your Ara ID.')
    info('It will never be shown again:')
    info('\n\n%s', table([ [ identity.mnemonic ] ]))
  } else {
    process.stdout.write(identity.did.did)
    process.stdout.write('\n')
    process.stdout.write(identity.mnemonic)
    process.stdout.write('\n')
  }

  return exit(0)
}

async function onresolve(argv) {
  // lazy require
  const { createChannel } = require('ara-network/discovery/channel')
  const { createCFS } = require('cfsnet/create')
  const aid = require('../')

  if (!argv.keyring && !argv.cache) {
    return onfatal(new TypeError('Expecting Ara network keyring file.'))
  }

  if (!argv.secret && !argv.cache) {
    return onfatal(new TypeError('Expecting Shared secret key.'))
  }

  if (!argv.network && !argv.cache) {
    return onfatal(new TypeError('Expecting Human readable network keys name.'))
  }

  if (!argv.identifier) {
    return onfatal(new Error('Missing identifier'))
  }

  if (
    0 === argv.identifier.indexOf('did:') &&
    0 !== argv.identifier.indexOf('did:ara:')
  ) {
    return onfatal(new Error('Expecting a did URI with an \'ara\' method.'))
  }

  try {
    if (argv['no-cache'] || argv.nocache || false === argv.cache) {
      argv.cache = false
    } else if (true === argv.cache) {
      argv.cache = true
    }

    const identity = await aid.resolve(argv.identifier, argv)

    let publicKey = null

    for (const pk of identity.publicKey) {
      const { fragment } = did.parse(pk.id)
      if ('owner' === fragment) {
        publicKey = Buffer.from(pk.publicKeyHex, 'hex')
        break
      }
    }

    if (argv.short) {
      process.stdout.write(identity.id)
    } else if (argv.peers) {
      const peers = []
      const seen = []
      await new Promise(async (resolve, reject) => {
        const channel = createChannel()
        const cfs = await createCFS({
          storage: ram,
          shallow: true,
          key: publicKey
        })

        channel.join(cfs.discoveryKey)
        channel.once('close', resolve)
        channel.once('error', reject)
        channel.on('peer', onpeer)

        timeout()
        await cfs.close()

        function onpeer(id, peer, type) {
          if (!seen.includes(peer.host + peer.port)) {
            timeout()

            peer.type = type
            peer.private = ip.isPrivate(peer.host)

            peers.push(peer)
            seen.push(peer.host + peer.port)
          }
        }

        function timeout(again) {
          clearTimeout(timeout.timer)
          if (false !== again) {
            timeout.timer = setTimeout(resolve, 500)
          }
        }
      })

      if (0 === peers.length) {
        warn(`Could not find any peers in the network for this identity: ${identity.id}`)
      }

      process.stdout.write(JSON.stringify(peers))
    } else if (argv.proof) {
      if (identity.proof) {
        process.stdout.write(JSON.stringify(identity.proof))
      } else {
        throw new Error('Resolution result does not contain a proof.')
      }
    } else if (argv.stats) {
      const counts = { services: 0, publicKeys: 0, authentications: 0 }
      const { created, updated, revoked } = identity

      if (identity.service) {
        counts.services = identity.service.length
      }

      if (identity.publicKey) {
        counts.publicKeys = identity.publicKey.length
      }

      if (identity.authentication) {
        counts.authentications = identity.authentication.length
      }

      const stats = {
        id: identity.id,
        created: created || null,
        updated: updated || null,
        revoked: revoked || null,
        services: counts.services,
        publicKeys: counts.publicKeys,
        authentications: counts.authentications,
      }

      process.stdout.write(JSON.stringify(stats))
    } else {
      process.stdout.write(JSON.stringify(new DIDDocument(identity)))
    }
  } catch (err) {
    return onfatal(err)
  }

  return exit(0)
}

async function onlist(argv) {
  const aid = require('../')

  try {
    debug('aid: list: %s', argv.path)

    const identities = await aid.list(argv.path)

    debug('aid: list: %d identities', identities.length)
    for (const id of identities) {
      process.stdout.write(`${id}\n`)
    }
  } catch (err) {
    return onfatal(err)
  }

  return exit(0)
}

async function onwhoami(argv) {
  const { whoami } = require('../whoami')

  try {
    const me = await whoami(argv)
    process.stdout.write(me)
    process.stdout.write('\n')
  } catch (err) {
    debug(err)
    return onfatal(err.message)
  }

  return exit(0)
}

async function onaddpublickey(argv) {
  const crypto = require('ara-crypto')
  const aid = require('../')

  const { identifier } = argv
  let { password, key } = argv

  if (!password) {
    const res = await inquirer.prompt([ {
      type: 'password',
      name: 'password',
      message:
      'Please enter the passphrase associated with the identity. \n' +
      'Passphrase:'
    } ])

    // eslint-disable-next-line prefer-destructuring
    password = res.password
    process.stdout.write('\n')
  }

  let publicKey = null

  try {
    const identity = await aid.resolve(identifier)

    for (const pk of identity.publicKey) {
      const { fragment } = did.parse(pk.id)
      if ('owner' === fragment) {
        publicKey = Buffer.from(pk.publicKeyHex, 'hex')
      }
    }

    const keystore = JSON.parse(await aid.fs.readFile(identity.id, 'keystore/ara'))
    const secretKey = ss.decrypt(keystore, {
      key: crypto.blake2b(Buffer.from(password)).slice(0, 16)
    })

    if (!Array.isArray(key)) {
      key = [ key ]
    }

    const ddo = aid.ddo.create(identity)
    const keys = await Promise.all(key.map(parseKey))

    for (const k of keys) {
      if (Array.isArray(k)) {
        for (const j of k) {
          ddo.addPublicKey(j)
        }
      } else {
        ddo.addPublicKey(k)
      }
    }

    const updated = await aid.update(identity.id, {
      password,
      publicKey,
      secretKey,
      ddo,
    })

    await aid.save(updated)
  } catch (err) {
    debug(err)
    return onfatal(new Error('Error while adding public key to DDO'))
  }

  process.stdout.write('\n')

  return exit(0)

  // eslint-disable-next-line no-shadow
  async function parseKey(key) {
    try {
      await pify(fs.access)(resolvePath(key))
      key = await pify(fs.readFile)(resolvePath(key), 'utf8')
    } catch (err) {
      debug(err)
    }

    return JSON.parse(key)
  }
}

async function onremovepublickey(argv) {
  const crypto = require('ara-crypto')
  const aid = require('../')

  const { key, identifier } = argv
  let { password } = argv

  if (!password) {
    const res = await inquirer.prompt([ {
      type: 'password',
      name: 'password',
      message:
      'Please enter the passphrase associated with the identity. \n' +
      'Passphrase:'
    } ])

    // eslint-disable-next-line prefer-destructuring
    password = res.password
    process.stdout.write('\n')
  }

  let publicKey = null

  try {
    const identity = await aid.resolve(identifier)

    for (const pk of identity.publicKey) {
      const { fragment } = did.parse(pk.id)
      if ('owner' === fragment) {
        publicKey = Buffer.from(pk.publicKeyHex, 'hex')
      }
    }

    const keystore = JSON.parse(await aid.fs.readFile(identity.id, 'keystore/ara'))
    const secretKey = ss.decrypt(keystore, {
      key: crypto.blake2b(Buffer.from(password)).slice(0, 16)
    })

    for (let i = 0; i < identity.publicKey.length; ++i) {
      const pk = identity.publicKey[i]
      const { fragment, reference: publicKeyReference } = did.parse(pk.id)
      if (key === fragment) {
        identity.publicKey.splice(i, 1)

        if (identity.proof && identity.proof.creator === publicKeyReference) {
          delete identity.proof
        }

        for (let j = 0; j < identity.authentication.length; ++j) {
          const auth = identity.authentication[j]
          const { reference } = did.parse(auth.publicKey)
          if (reference === publicKeyReference) {
            identity.authentication.splice(j, 1)
            break
          }
        }

        break
      }
    }

    const ddo = aid.ddo.create(identity)

    const updated = await aid.update(identity.id, {
      password,
      publicKey,
      secretKey,
      ddo,
    })

    await aid.save(updated)
  } catch (err) {
    debug(err)
    return onfatal(new Error('Error while adding public key to DDO'))
  }

  process.stdout.write('\n')

  return exit(0)
}

async function onexportpublickey(argv) {
  const aid = require('../')

  const { key, identifier } = argv

  if (Array.isArray(key)) {
    process.stdout.write('[')
  }

  try {
    const identity = await aid.resolve(identifier, argv)
    let first = true
    for (const pk of identity.publicKey) {
      const { fragment } = did.parse(pk.id)
      if (!Array.isArray(key) && key === fragment) {
        process.stdout.write(JSON.stringify(pk))
        break
      } else if (Array.isArray(key) && key.includes(fragment)) {
        if (!first) {
          process.stdout.write(',')
        }

        process.stdout.write(JSON.stringify(pk))
        first = false
      }
    }
  } catch (err) {
    return onfatal(err)
  } finally {
    if (Array.isArray(key)) {
      process.stdout.write(']')
    }
  }

  return exit(0)
}

async function onkeystoredump(argv) {
  const { resolveDNS, toHex } = require('../util')
  const protobuf = require('../protobuf')
  const crypto = require('ara-crypto')
  const aid = require('../')

  const secretStorage = argv['secret-storage']
  let { identifier, password } = argv

  if ('ara' !== argv.type && 'eth' !== argv.type) {
    return onfatal(new Error('Invalid type passed. Type should be either eth or ara'))
  }

  if (!identifier) {
    error('Identifier not given.')
    return exit(1)
  }

  if (!password) {
    const res = await inquirer.prompt([ {
      type: 'password',
      name: 'password',
      message:
      'Please enter the passphrase associated with the identity. \n' +
      'Passphrase:'
    } ])

    // eslint-disable-next-line prefer-destructuring
    password = res.password
    process.stdout.write('\n')
  }
  const secretKeys = { ara: null, eth: null }
  const keystores = { ara: null, eth: null }

  if (isDomainName(identifier)) {
    identifier = await resolveDNS(identifier)
  }

  keystores.ara = await aid.fs.readFile(identifier, 'keystore/ara')
  keystores.eth = await aid.fs.readFile(identifier, 'keystore/eth')

  try {
    const passwordBuffer = crypto.blake2b(Buffer.from(password))
    const key = passwordBuffer.slice(0, 16)
    secretKeys.ara = ss.decrypt(JSON.parse(keystores.ara), { key })
  } catch (err) {
    debug(err)
    return onfatal(new Error('Invalid passphrase when decoding ara keystore.'))
  }

  if (secretStorage) {
    if ('ara' === argv.type) {
      process.stdout.write(keystores.ara)
    } else {
      try {
        const ethKeystore = await protobuf.messages.KeyStore.decode(ss.decrypt(
          JSON.parse(keystores.eth),
          { key: secretKeys.ara.slice(0, 16) }
        ))

        process.stdout.write(JSON.stringify(ethKeystore))
      } catch (err) {
        debug(err)
        return onfatal(new Error('Error while decoding the web3 ethereum keystore'))
      }
    }
  } else {
    if ('ara' === argv.type) {
      process.stdout.write(toHex(secretKeys.ara))
    }

    if ('eth' === argv.type) {
      try {
        secretKeys.eth = await aid
          .ethereum
          .keystore
          .recover(password, keystores.ara, keystores.eth)

        process.stdout.write(toHex(secretKeys.eth))
      } catch (err) {
        debug(err)
        return onfatal(new Error('Error while decrypting the ethereum keystore'))
      }
    }
  }

  process.stdout.write('\n')

  return exit(0)
}

async function onaddservice(argv) {
  const crypto = require('ara-crypto')
  const aid = require('../')

  const { identifier } = argv
  let { password } = argv

  if (!password) {
    const res = await inquirer.prompt([ {
      type: 'password',
      name: 'password',
      message:
      'Please enter the passphrase associated with the identity. \n' +
      'Passphrase:'
    } ])

    // eslint-disable-next-line prefer-destructuring
    password = res.password
    process.stdout.write('\n')
  }

  let publicKey = null

  try {
    const identity = await aid.resolve(identifier)

    for (const pk of identity.publicKey) {
      const { fragment } = did.parse(pk.id)
      if ('owner' === fragment) {
        publicKey = Buffer.from(pk.publicKeyHex, 'hex')
      }
    }

    const ddo = aid.ddo.create(identity)

    const keystore = JSON.parse(await aid.fs.readFile(identity.id, 'keystore/ara'))
    const secretKey = ss.decrypt(keystore, {
      key: crypto.blake2b(Buffer.from(password)).slice(0, 16)
    })

    const config = {
      id: `${identity.id};${argv.id}`,
      type: argv.type,
      serviceEndpoint: argv.endpoint,
    }

    if (argv.config) {
      try {
        const serviceConfigPath = resolvePath(argv.config)
        await pify(fs.access)(serviceConfigPath)
        const buffer = await pify(fs.readFile)(serviceConfigPath)
        const serviceConfig = JSON.parse(buffer)

        if ('object' === typeof serviceConfig) {
          Object.assign(config, serviceConfig)
        }
      } catch (err) {
        debug(err)
        try {
          const serviceConfig = JSON.parse(argv.config)
          if ('object' === typeof serviceConfig) {
            Object.assign(config, serviceConfig)
          }
        } catch (err2) {
          debug(err2)
        }
      }
    }

    ddo.addService(config)

    const updated = await aid.update(identity.id, {
      publicKey,
      secretKey,
      password,
      ddo,
    })

    await aid.save(updated)
  } catch (err) {
    debug(err)
    return onfatal(new Error('Error while adding service to DDO'))
  }

  process.stdout.write('\n')

  return exit(0)
}

async function onremoveservice(argv) {
  const crypto = require('ara-crypto')
  const aid = require('../')

  const { identifier } = argv
  let { password } = argv

  if (!password) {
    const res = await inquirer.prompt([ {
      type: 'password',
      name: 'password',
      message:
      'Please enter the passphrase associated with the identity. \n' +
      'Passphrase:'
    } ])

    // eslint-disable-next-line prefer-destructuring
    password = res.password
    process.stdout.write('\n')
  }

  let publicKey = null

  try {
    const identity = await aid.resolve(identifier)

    for (const pk of identity.publicKey) {
      const { fragment } = did.parse(pk.id)
      if ('owner' === fragment) {
        publicKey = Buffer.from(pk.publicKeyHex, 'hex')
      }
    }

    const keystore = JSON.parse(await aid.fs.readFile(identity.id, 'keystore/ara'))
    const secretKey = ss.decrypt(keystore, {
      key: crypto.blake2b(Buffer.from(password)).slice(0, 16)
    })

    for (let i = 0; i < identity.service.length; ++i) {
      const service = identity.service[i]
      const parts = service.id.split(';')
      const shortId = parts[1]

      if (argv.id === shortId || argv.id === service.id) {
        identity.service.splice(i, 1)
        break
      }
    }

    const ddo = aid.ddo.create(identity)

    const updated = await aid.update(identity.id, {
      password,
      publicKey,
      secretKey,
      ddo,
    })

    await aid.save(updated)
  } catch (err) {
    debug(err)
    return onfatal(new Error('Error while removing service from DDO'))
  }

  process.stdout.write('\n')

  return exit(0)
}

async function onexportservice(argv) {
  const aid = require('../')

  const { identifier } = argv

  if (Array.isArray(argv.id)) {
    process.stdout.write('[')
  }

  try {
    const identity = await aid.resolve(identifier, argv)
    let first = true

    for (let i = 0; i < identity.service.length; ++i) {
      const service = identity.service[i]
      const parts = service.id.split(';')
      const shortId = parts[1]

      if (
        !Array.isArray(argv.id) &&
        (argv.id === shortId || argv.id === service.id)
      ) {
        process.stdout.write(JSON.stringify(service))
        break
      }

      if (
        Array.isArray(argv.id) &&
        (argv.id.includes(service.id) || argv.id.includes(shortId))
      ) {
        if (!first) {
          process.stdout.write(',')
        }

        process.stdout.write(JSON.stringify(service))
        first = false
      }
    }
  } catch (err) {
    return onfatal(err)
  } finally {
    if (Array.isArray(argv.id)) {
      process.stdout.write(']')
    }
  }

  return exit(0)
}

async function onsign(argv) {
  const aid = require('../')

  let { password } = argv

  if ('string' === typeof password) {
    try {
      await pify(fs.access)(password)
      password = await pify(fs.readFile)(password, 'utf8')
    } catch (err) {
      void err
    }
  }

  if (!password) {
    ({ password } = await inquirer.prompt([ {
      type: 'password',
      name: 'password',
      message:
      'Please provide a passphrase for your identity. This is needed to ' +
      'sign a message with your identity.\n' +
      'Passphrase:'
    } ]))
  }

  if (!password) {
    // eslint-disable-next-line function-paren-newline
    return onfatal(
      new TypeError('Please provide a password to sign a message with your identity.'))
  }

  argv.password = password
  const signature = await aid.sign(argv.identifier, argv.message, argv)

  if (argv.binary) {
    process.stdout.write(signature)
  } else {
    process.stdout.write(signature.toString(argv.encoding || 'hex'))
  }

  return exit(0)
}

async function onverify(argv) {
  const aid = require('../')
  let verified = false
  let signature = null

  if ('string' === typeof argv.signature) {
    try {
      await pify(fs.access)(argv.signature)
      signature = await pify(fs.readFile)(argv.signature)
    } catch (err) {
      void err
    }
  }

  if (null === signature) {
    signature = Buffer.from(argv.signature, argv.encoding || 'hex')
  }

  try {
    verified = await aid.verify(argv.identifier, signature, argv.message, argv)
  } catch (err) {
    debug(err)
    return exit(1)
  }

  return exit(verified ? 0 : 1)
}

async function onbinddns(argv) {
  const crypto = require('ara-crypto')
  const aid = require('../')

  let { password } = argv

  if ('string' === typeof password) {
    try {
      await pify(fs.access)(password)
      password = await pify(fs.readFile)(password, 'utf8')
    } catch (err) {
      void err
    }
  }

  if (!password) {
    ({ password } = await inquirer.prompt([ {
      type: 'password',
      name: 'password',
      message:
      'Please provide a passphrase for your identity. This is needed to ' +
      'sign a message with your identity.\n' +
      'Passphrase:'
    } ]))
  }

  if (!password) {
    // eslint-disable-next-line function-paren-newline
    return onfatal(
      new TypeError('Please provide a password to sign a message with your identity.'))
  }

  argv.password = password

  try {
    const identity = await aid.resolve(argv.identifier)
    argv.ddo = identity

    for (const pk of identity.publicKey) {
      const { fragment } = did.parse(pk.id)
      if ('owner' === fragment) {
        argv.publicKey = Buffer.from(pk.publicKeyHex, 'hex')
        break
      }
    }

    const keystore = JSON.parse(await aid.fs.readFile(identity.id, 'keystore/ara'))
    argv.secretKey = ss.decrypt(keystore, {
      key: crypto.blake2b(Buffer.from(password)).slice(0, 16)
    })
  } catch (err) {
    return onfatal(err)
  }

  try {
    const identity = await aid.dns.bind(argv.identifier, argv.domain, argv)
    await aid.save(identity)
  } catch (err) {
    return onfatal(err)
  }

  return exit(0)
}

async function onunbinddns(argv) {
  const crypto = require('ara-crypto')
  const aid = require('../')

  let { password } = argv

  if ('string' === typeof password) {
    try {
      await pify(fs.access)(password)
      password = await pify(fs.readFile)(password, 'utf8')
    } catch (err) {
      void err
    }
  }

  if (!password) {
    ({ password } = await inquirer.prompt([ {
      type: 'password',
      name: 'password',
      message:
      'Please provide a passphrase for your identity. This is needed to ' +
      'sign a message with your identity.\n' +
      'Passphrase:'
    } ]))
  }

  if (!password) {
    // eslint-disable-next-line function-paren-newline
    return onfatal(
      new TypeError('Please provide a password to sign a message with your identity.'))
  }

  argv.password = password

  try {
    const identity = await aid.resolve(argv.identifier)
    argv.ddo = identity

    for (const pk of identity.publicKey) {
      const { fragment } = did.parse(pk.id)
      if ('owner' === fragment) {
        argv.publicKey = Buffer.from(pk.publicKeyHex, 'hex')
        break
      }
    }

    const keystore = JSON.parse(await aid.fs.readFile(identity.id, 'keystore/ara'))
    argv.secretKey = ss.decrypt(keystore, {
      key: crypto.blake2b(Buffer.from(password)).slice(0, 16)
    })
  } catch (err) {
    return onfatal(err)
  }

  try {
    const identity = await aid.dns.unbind(argv.identifier, argv.domain, argv)
    await aid.save(identity)
  } catch (err) {
    return onfatal(err)
  }

  return exit(0)
}

function onfatal(err) {
  debug(err)
  error('fatal:', err.message)
  exit(1)
}

function exit(code) {
  process.nextTick(process.exit, code)
}
