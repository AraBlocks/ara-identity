#!/usr/bin/env node

const { info, warn, error } = require('ara-console')
const { writeIdentity } = require('../util')
const { toHex } = require('../util')
const { table } = require('table')
const protobuf = require('../protobuf')
const inquirer = require('inquirer')
const program = require('yargs')
const crypto = require('ara-crypto')
const debug = require('debug')('ara:identity')
const pify = require('pify')
const did = require('did-uri')
const aid = require('../')
const rc = require('../rc')()
const ss = require('ara-secret-storage')
const fs = require('fs')
const { DEFAULT_ARCHIVER_MAX_CONNECTIONS } = require('../archive')

process.on('unhandledRejection', onfatal)
process.on('uncaughtException', onfatal)

const ellipsis = (s, x, y) => s.slice(x || 0, y || 4)

program
  .usage('usage: $0 [-hqDV] <command> [options]')
  .wrap(null)

program
  .group([ 'help', 'quiet', 'debug', 'version' ], 'General Options:')
  .option('help', {
    alias: 'h',
    describe: 'Show this help message',
  })
  .option('quiet', {
    alias: 'q',
    describe: 'Only output errors and results'
  })
  .option('debug', {
    alias: 'D',
    describe: 'Enable debug output',
  })
  .option('version', {
    alias: 'V',
    describe: 'Show program version'
  })

program.command(
  'create',
  'Create an identity',
  // eslint-disable-next-line no-shadow
  program => program
    .usage('usage: $0 create [-D] [options]')
  , oncreate
)

program.command(
  'archive [identifier]',
  'Archive identity in network',
  // eslint-disable-next-line no-shadow
  program => program
    .usage('usage: $0 archive [-D] [options] [identifier]')
    .positional('identifier', {
      default:
        rc.network.identity.archiver.whoami ||
        rc.network.identity.whoami ||
        rc.network.whoami,
    })
    .group([ 'secret', 'keyring', 'network' ], 'Network Options:')
    .option('secret', {
      alias: 's',
      describe: 'Shared secret key for the associated network keys',
      required: true,
      requiresArg: true,
      default:
        rc.network.identity.archiver.secret ||
        rc.network.identity.secret ||
        rc.network.secret
    })
    .option('keyring', {
      alias: 'k',
      describe: 'Path to Ara network keyring file',
      required: true,
      requiresArg: true,
      default:
        rc.network.identity.archiver.keyring ||
        rc.network.identity.keyring ||
        rc.network.keyring,
    })
    .option('network', {
      alias: 'n',
      describe: 'Human readable network name for keys in keyring',
      required: true,
      requiresArg: true,
      default: rc.network.identity.archiver.network,
    })
    .option('max-connections', {
      describe: 'Maximum number of Archivers to find',
      required: true,
      requiresArg: true,
      default: DEFAULT_ARCHIVER_MAX_CONNECTIONS,
    })
    .option('shallow', {
      describe: 'Only archive the ddo',
      required: true,
      requiresArg: true,
      default: false,
    })
  , onarchive
)

program.command(
  'resolve [identifier]',
  'Resolve an identity',
  // eslint-disable-next-line no-shadow
  program => program
    .usage('usage: $0 resolve [-D] [options] [identifier]')
    .positional('identifier', {
      default:
        rc.network.identity.resolver.whoami ||
        rc.network.identity.whoami ||
        rc.network.whoami,
    })

    .group([ 'proof', 'short', 'stats' ], 'Output Options:')
    .option('proof', {
      describe: 'Output just the DID proof from the resolution result.',
      requiresArg: false,
      type: 'boolean',
    })
    .option('short', {
      describe: 'Output just the DID ID from the resolution result.',
      requiresArg: false,
      type: 'boolean',
    })
    .option('stats', {
      describe: 'Output just the DID stats from the resolution result.',
      requiresArg: false,
      type: 'boolean',
    })

    .group([ 'secret', 'keyring', 'network' ], 'Network Options:')
    .option('secret', {
      alias: 's',
      describe: 'Shared secret key for the associated network keys.',
      requiresArg: true,
      default:
        rc.network.identity.resolver.secret ||
        rc.network.identity.secret ||
        rc.network.secret
    })
    .option('network', {
      alias: 'n',
      describe: 'Human readable network name for keys in keyring',
      requiresArg: true,
      default: rc.network.identity.resolver.network,
    })
    .option('keyring', {
      alias: 'k',
      describe: 'Path to Ara network keyring file',
      requiresArg: true,
      default:
        rc.network.identity.resolver.keyring ||
        rc.network.identity.keyring ||
        rc.network.keyring,
    })

    .group([ 'cache', 'timeout' ], 'Resolution Options:')
    .option('cache', {
      type: 'boolean',
      alias: 'C',
      describe: 'Enable or disable cache',
      default: true,
    })
    .option('timeout', {
      alias: 't',
      describe: 'Resolution timeout',
    })
  , onresolve
)

program.command(
  'list',
  'Output local identities',
  // eslint-disable-next-line no-shadow
  program => program
    .usage('usage: $0 list [-D] [options]')
    .group([ 'path' ], 'List Options:')
    .option('path', {
      alias: 'p',
      describe: 'Path to look for identities',
      optional: true
    })
  , onlist
)

program.command(
  'whoami',
  'Output current Ara identity in context (.ararc)',
  // eslint-disable-next-line no-shadow
  program => program
    .usage('usage: $0 whoami [-D] [options]')
    .group([ 'secret', 'keyring', 'network' ], 'Network Options:')
    .option('secret', {
      alias: 's',
      describe: 'Shared secret key for the associated network keys.',
      requiresArg: true,
      default:
        rc.network.identity.resolver.secret ||
        rc.network.identity.secret ||
        rc.network.secret
    })
    .option('network', {
      alias: 'n',
      describe: 'Human readable network name for keys in keyring',
      requiresArg: true,
      default: rc.network.identity.resolver.network,
    })
    .option('keyring', {
      alias: 'k',
      describe: 'Path to Ara network keyring file',
      requiresArg: true,
      default:
        rc.network.identity.resolver.keyring ||
        rc.network.identity.keyring ||
        rc.network.keyring,
    })
    .group([ 'cache', 'timeout' ], 'Resolution Options:')
    .option('cache', {
      type: 'boolean',
      alias: 'C',
      describe: 'Enable or disable cache',
      default: true,
    })
    .option('timeout', {
      alias: 't',
      describe: 'Resolution timeout',
    })
  , onwhoami
)

program.command(
  'recover',
  'Recover an Ara identity using a mnemonic',
  // eslint-disable-next-line no-shadow
  program => program
    .usage('usage: $0 [-D] recover [options]')
    .group([ 'mnemonic' ], 'Recovery Options:')
    .option('mnemonic', {
      alias: 'm',
      describe: 'Valid bip39 mnemonic',
      required: true,
      requiresArg: true,
    })
  , onrecover
)

program.command(
  'keystore-dump [identifier] [type]',
  'Recover secret keys and secret storages for Ara and Web3',
  // eslint-disable-next-line no-shadow
  program => program
    .usage('usage: $0 keystore-dump [-D] [options] [identifier]')
    .positional('identifier', {
      default: rc.network.identity.whoami || rc.network.whoami,
    })
    .positional('type', {
      default: 'eth',
    })
    .group([ 'secret-storage', 'path' ], 'Options:')
    .option('secret-storage', {
      alias: 'S',
      type: 'boolean',
      default: false,
      optional: true,
      describe: 'Set true if secret storage needs to be retrieved'
    })
    .option('path', {
      alias: 'p',
      optional: true,
      describe: 'Path to look for did directory'
    })
  , onkeystoredump
)

program.command(
  'revoke',
  'Revoke an Ara identity using a mnemonic',
  // eslint-disable-next-line no-shadow
  program => program
    .usage('usage: $0 [-D] revoke [options]')
    .group([ 'mnemonic' ], 'Revoke Options:')
    .option('mnemonic', {
      alias: 'm',
      describe: 'Valid bip39 mnemonic',
      required: true,
      requiresArg: true,
    })
  , onrevoke
)

program
  .recommendCommands()
  .completion('completion', false)

void program.getOptions().boolean.splice(-2)

try {
  if (0 === program.argv._.length) {
    program.showHelp()
    process.exit(1)
  }
} catch (err) {
  debug(err)
  process.exit(1)
}

if (program.argv.debug) {
  // eslint-disable-next-line global-require
  require('debug').enable('ara:identity*')
}

async function onrecover(argv) {
  const { mnemonic } = argv
  let { password } = argv

  if ('string' === typeof password) {
    try {
      await pify(fs.access)(password)
      password = String(await pify(fs.readFile)(password))
    } catch (err) {
      void err
    }
  }

  if (!password) {
    ({ password } = await inquirer.prompt([ {
      type: 'password',
      name: 'password',
      message:
      'Your identity\'s keystore will be secured by a passphrase ' +
      'after recovery. \n' +
      'Please provide a passphrase. Do not forget this as it will never be ' +
      'shown to you.\n' +
      'Passphrase:'
    } ]))
  }

  if (!password) {
    // eslint-disable-next-line function-paren-newline
    onfatal(
      new TypeError('A new passphrase is required to recover the identity.'))
  }

  try {
    const identity = await aid.recover({ password, mnemonic })
    info('Identity recovered : %s', identity.did)

    for (let i = 0; i < identity.files.length; ++i) {
      warn('Will write identity file: %s', identity.files[i].path)
    }

    await writeIdentity(identity)
    info('Identity recovered successfully.')
  } catch (err) {
    onfatal(err)
  }

  process.exit(0)
}

async function onrevoke(argv) {
  const { mnemonic } = argv
  let { password } = argv

  if (!password) {
    ({ password } = await inquirer.prompt([ {
      type: 'password',
      name: 'password',
      message:
      'Please provide a passphrase. Do not forget this as it will never be ' +
      'shown to you and will be required to archive your identity after revoking.\n' +
      'Passphrase:'
    } ]))
  }

  if (!password) {
    // eslint-disable-next-line function-paren-newline
    onfatal(
      new TypeError('A passphrase is required to revoke your identity.'))
  }

  try {
    const identity = await aid.revoke({ password, mnemonic })
    info('Identity to be revoked : %s', identity.did)

    for (let i = 0; i < identity.files.length; ++i) {
      warn('Will write identity file: %s', identity.files[i].path)
    }

    await writeIdentity(identity)
    info('Identity revoked successfully.')
  } catch (err) {
    onfatal(err)
  }

  process.exit(0)
}

async function onarchive(argv) {
  let { password } = argv

  if ('string' === typeof password) {
    try {
      await pify(fs.access)(password)
      password = await pify(fs.readFile)(password, 'utf8')
    } catch (err) {
      void err
    }
  }

  if (!password) {
    ({ password } = await inquirer.prompt([ {
      type: 'password',
      name: 'password',
      message:
      'Please provide a passphrase for your identity. This is needed to ' +
      'archive your identity.\n' +
      'Passphrase:'
    } ]))
  }

  if (!password) {
    // eslint-disable-next-line function-paren-newline
    onfatal(
      new TypeError('Please provide a password to archive your identity.'))
  }

  password = crypto.blake2b(Buffer.from(password))

  const ddo = await aid.resolve(argv.identifier, argv)
  const { identifier } = did.parse(ddo.id)

  let identityBuffer = null
  let identity = null

  const stats = {
    totalConnections: 0
  }

  const maxConnections = argv['max-connections']
  const {
    keyring,
    network,
    secret,
    shallow
  } = argv

  let secretKey = null
  let publicKey = null

  try {
    const keystoreBuffer = await aid.fs.readFile(identifier, 'keystore/ara')
    const keystore = JSON.parse(String(keystoreBuffer))

    try {
      secretKey = ss.decrypt(keystore, { key: password.slice(0, 16) })
      publicKey = secretKey.slice(32)
    } catch (err) {
      debug(err)
      onfatal(new Error('Invalid passphrase when decoding keystore.'))
    }

    identityBuffer = await aid.fs.readFile(identifier, 'identity', argv)
  } catch (err) {
    error('Unable to read identity.')
    onfatal(err)
  }

  try {
    identity = protobuf.messages.Identity.decode(identityBuffer)
  } catch (err) {
    error('Failed to decode identity.')
    onfatal(err)
  }

  const { files } = identity

  try {
    // manually construct identity file for archiver
    files.push({
      path: 'identity',
      buffer: identityBuffer
    })

    warn('Archiving new identity for network \'%s\'.', keyring)
    const didArchive = await aid.archive({
      publicKey,
      secretKey,
      files
    }, {
      network,
      secret,
      keyring,
      maxConnections,
      shallow,

      onhello,
      onauth,
      onokay,

      onclose,
      onerror,
    })

    info(
      '%d connection%s made',
      stats.totalConnections,
      1 === stats.totalConnections ? '' : 's',
    )

    if (didArchive) {
      info('Successfully archived identity to network "%s"', network)
      process.nextTick(() => process.exit(0))
    } else {
      error('Failed to archive identity')
      process.nextTick(() => process.exit(1))
    }
  } catch (err) {
    error('Failed to archive identity.')
    onfatal(err)
  }

  function onhello(hello) {
    info(
      'Got hello from archiver node: key=%s mac=%s',
      toHex(ellipsis(hello.publicKey)),
      toHex(ellipsis(hello.mac)),
    )
  }

  function onauth(auth) {
    info(
      'Authenticated with archiver node: key=%s signature=%s',
      toHex(ellipsis(auth.publicKey)),
      toHex(ellipsis(auth.signature)),
    )
  }

  function onokay(okay) {
    info(
      'Got okay from archiver node: signature=%s',
      toHex(ellipsis(okay)),
    )
  }

  function onclose(rinfo) {
    stats.totalConnections = rinfo.totalConnections
    debug(
      'Connection #%d to %s:%s@%s closed.',
      rinfo.peerIndex,
      rinfo.peer.host,
      rinfo.peer.port,
      toHex(ellipsis(rinfo.discoveryKey)),
    )
  }

  function onerror(err) {
    debug(err.stack || err)
    error('Got error in archiver:', err.message)
  }
}

async function oncreate(argv) {
  let { password } = argv

  if ('string' === typeof password) {
    try {
      await pify(fs.access)(password)
      password = String(await pify(fs.readFile)(password))
    } catch (err) {
      void err
    }
  }

  if (!password) {
    ({ password } = await inquirer.prompt([ {
      type: 'password',
      name: 'password',
      message:
      'Your identity\'s keystore will be secured by a passphrase. \n' +
      'Please provide a passphrase. Do not forget this as it will never be ' +
      'shown to you.\n' +
      'Passphrase:'
    } ]))
  }

  if (!password) {
    // eslint-disable-next-line function-paren-newline
    onfatal(
      new TypeError('A new passphrase is required to secure the identity.'))
  }

  if (!argv.quiet) { process.stdout.write('\n') }

  const identity = await aid.create({ password })

  if (!argv.quiet) { info('New identity created: %s', identity.did) }

  if (!argv.quiet) {
    for (let i = 0; i < identity.files.length; ++i) {
      warn('Will write identity file: %s', identity.files[i].path)
    }
  }

  await writeIdentity(identity)

  if (!argv.quiet) {
    info('Please safely store the following 12 word mnemonic phrase for this')
    info('Ara ID. This phrase will be required to restore your Ara ID.')
    info('It will never be shown again:')
    info('\n\n%s', table([ [ identity.mnemonic ] ]))
  } else {
    process.stdout.write(identity.mnemonic)
    process.stdout.write('\n')
  }

  process.exit(0)
}

async function onresolve(argv) {
  if (!argv.keyring && !argv.cache) {
    onfatal(new TypeError('Expecting Ara network keyring file.'))
  }

  if (!argv.secret && !argv.cache) {
    onfatal(new TypeError('Expecting Shared secret key.'))
  }

  if (!argv.network && !argv.cache) {
    onfatal(new TypeError('Expecting Human readable network keys name.'))
  }

  if (0 === argv.identifier.indexOf('did:') && 0 !== argv.identifier.indexOf('did:ara:')) {
    onfatal(new Error('Expecting a did URI with an \'ara\' method.'))
  }

  try {
    let cache

    const {
      timeout,
      keyring,
      network,
      secret,
    } = argv

    if (argv['no-cache'] || argv.nocache || false === argv.cache) {
      cache = false
    } else if (true === argv.cache) {
      cache = true
    }

    const identity = await aid.resolve(argv.identifier, {
      network,
      keyring,
      timeout,
      secret,
      cache,
    })

    if (argv.short) {
      process.stdout.write(identity.id)
    } else if (argv.proof) {
      if (identity.proof) {
        process.stdout.write(JSON.stringify(identity.proof))
      } else {
        throw new Error('Resolution result does not contain a proof.')
      }
    } else if (argv.stats) {
      const counts = { services: 0, publicKeys: 0, authentications: 0 }
      const { created, updated, revoked } = identity

      if (identity.services) {
        counts.services = identity.services.length
      }

      if (identity.publicKeys) {
        counts.publicKeys = identity.publicKeys.length
      }

      if (identity.authentications) {
        counts.authentications = identity.authentications.length
      }

      const stats = {
        id: identity.id,
        created: created || null,
        updated: updated || null,
        revoked: revoked || null,
        services: counts.services,
        publicKeys: counts.publicKeys,
        authentications: counts.authentications,
      }

      process.stdout.write(JSON.stringify(stats))
    } else {
      process.stdout.write(JSON.stringify(identity))
    }
  } catch (err) {
    onfatal(err)
  }

  process.exit(0)
}

async function onlist(argv) {
  try {
    debug('aid: list: %s', argv.path)

    const identities = await aid.list(argv.path)

    debug('aid: list: %d identities', identities.length)
    for (const id of identities) {
      process.stdout.write(`${id}\n`)
    }

    process.exit(0)
  } catch (err) {
    onfatal(err)
  }
}

async function onwhoami(argv) {
  const identifier = rc.network.identity.whoami || rc.network.whoami
  let ddo = null
  let cache

  const {
    timeout,
    keyring,
    network,
    secret,
  } = argv

  if (!identifier) {
    error('Identifier not given.')
    process.exit(1)
    return
  }

  if (argv['no-cache'] || argv.nocache || false === argv.cache) {
    cache = false
  } else if (true === argv.cache) {
    cache = true
  }

  try {
    const _did = aid.did.normalize(identifier)
    ddo = JSON.parse(await aid.fs.readFile(_did.identifier, 'ddo.json', argv))
  } catch (err) {
    try {
      ddo = await aid.resolve(identifier, {
        network,
        keyring,
        timeout,
        secret,
        cache,
      })
    } catch (err2) {
      debug(err2)
      onfatal(new Error(`Unable to resolve identity: ${identifier}.`))
    }
  }

  if (!ddo) {
    onfatal(new Error('Missing or malformed identity document (ddo.json).'))
  }

  process.stdout.write(ddo.id)
  process.stdout.write('\n')
  process.exit(0)
}

async function onkeystoredump(argv) {
  const secretStorage = argv['secret-storage']
  let { identifier, password } = argv

  if ('ara' !== argv.type && 'eth' !== argv.type) {
    onfatal(new Error('Invalid type passed. Type should be either eth or ara'))
  }

  if (identifier && 0 !== identifier.indexOf('did:ara:')) {
    // eslint-disable-next-line no-param-reassign
    identifier = `did:ara:${identifier}`
  }

  if (!identifier) {
    error('Identifier not given.')
    process.exit(1)
    return
  }

  if (!password) {
    const res = await inquirer.prompt([ {
      type: 'password',
      name: 'password',
      message:
      'Please enter the passphrase associated with the identity. \n' +
      'Passphrase:'
    } ])

    // eslint-disable-next-line prefer-destructuring
    password = res.password
    process.stdout.write('\n')
  }

  const secretKeys = { ara: null, eth: null }
  const keystores = { ara: null, eth: null }

  keystores.ara = await aid.fs.readFile(identifier, 'keystore/ara')
  keystores.eth = await aid.fs.readFile(identifier, 'keystore/eth')

  try {
    const passwordBuffer = crypto.blake2b(Buffer.from(password))
    const key = passwordBuffer.slice(0, 16)
    secretKeys.ara = ss.decrypt(JSON.parse(keystores.ara), { key })
  } catch (err) {
    debug(err)
    onfatal(new Error('Invalid passphrase when decoding ara keystore.'))
  }

  if (secretStorage) {
    if ('ara' === argv.type) {
      process.stdout.write(keystores.ara)
    } else {
      try {
        const ethKeystore = await protobuf.messages.KeyStore.decode(ss.decrypt(
          JSON.parse(keystores.eth),
          { key: secretKeys.ara.slice(0, 16) }
        ))

        process.stdout.write(JSON.stringify(ethKeystore))
      } catch (err) {
        debug(err)
        onfatal(new Error('Error while decoding the web3 ethereum keystore'))
      }
    }
  } else {
    if ('ara' === argv.type) {
      process.stdout.write(toHex(secretKeys.ara))
    }

    if ('eth' === argv.type) {
      try {
        secretKeys.eth = await aid
          .ethereum
          .keystore
          .recover(password, keystores.ara, keystores.eth)

        process.stdout.write(toHex(secretKeys.eth))
      } catch (err) {
        debug(err)
        onfatal(new Error('Error while decrypting the ethereum keystore'))
      }
    }
  }

  process.stdout.write('\n')
  process.exit(0)
}

function onfatal(err) {
  debug(err)
  error('fatal:', err.message)
  process.exit(1)
}
