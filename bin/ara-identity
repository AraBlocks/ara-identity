#!/usr/bin/env node

const { basename, dirname, resolve } = require('path')
const { info, warn, error } = require('ara-console')
const { createSwarm } = require('ara-network/discovery')
const { createCFS } = require('cfsnet/create')
const { toHex } = require('../util')
const protobuf = require('../protobuf')
const inquirer = require('inquirer')
const context = require('ara-context')()
const program = require('yargs')
const secrets = require('ara-network/secrets')
const crypto = require('ara-crypto')
const extend = require('extend')
const mirror = require('mirror-folder')
const mkdirp = require('mkdirp')
const debug = require('debug')('ara:identity')
const pify = require('pify')
const did = require('did-uri')
const aid = require('../')
const ram = require('random-access-memory')
const fs = require('fs')
const os = require('os')
const rc = require('../rc')()

const noop = () => void 0
const $0 = basename(process.argv[1] || package.name)

process.on('unhandledRejection', onfatal)
process.on('uncaughtException', onfatal)

const { argv } = program
  .usage("usage: $0 [-hDV] [options] <command> [options]")
  .option('debug', {
    type: 'boolean',
    alias: 'D',
    describe: "Enable debug output",
  })
  .option('force', {
    alias: 'f',
    type: 'boolean',
    describe: "Force actions without prompt",
  })
  .option('help', {
    alias: 'h',
    describe: "Show this help message"
  })
  .option('key', {
    alias: 'k',
    type: 'string',
    describe: "Network key name",
  })
  .option('version', {
    alias: 'V',
    describe: "Show program version"
  })
  .command('archive [did]', "Archive identity in network", (program) => {
    program
      .positional('did', {
        type: 'string',
        describe: "An ARA decentralized identity (did) URI"
      })
  }, onarchive)
  .command('create', "Create an identity", (program) => {
    program
      .option('archive', {
        alias: 'A',
        type: 'boolean',
        describe: "Archive identity into network",
      })
  }, oncreate)
  .command('import [did]', "Import an identity from the network", (program) => {
    program
      .positional('did', {
        type: 'string',
        describe: "An ARA decentralized identity (did) URI"
      })
      .option('cache', {
        alias: 'C',
        type: 'boolean',
        describe: "Enable or disable cache",
        default: true
      })
      .option('no-cache', {
        type: 'boolean',
        describe: "Skip identity cache",
      })
      .option('timeout', {
        alias: 't',
        type: 'number',
        describe: "Resolution timeout",
      })
  }, onimport)
  .command('keys [did]', "Output keys for an identity", (program) => {
  }, onkeys)
  .command('resolve [did]', "Resolve an identity", (program) => {
    program
      .option('cache', {
        alias: 'C',
        type: 'boolean',
        describe: "Enable or disable cache",
        default: true
      })
      .option('no-cache', {
        alias: 'nocache',
        type: 'boolean',
        describe: "Skip identity cache",
      })
      .option('timeout', {
        alias: 't',
        type: 'number',
        describe: "Resolution timeout",
      })
  }, onresolve)
  .command('list', "Outputs a list of all identities created locally", (program) => {
    program
      .option('path', {
        alias: 'p',
        type: 'string',
        describe: "Path to look for identities (Optional)"
      })
  }, onlist)

void async function main() {
  if (program.argv.debug) {
    require('debug').enable('ara:identity*')
  }
}()

async function onarchive(argv) {
  if (null == argv.key) {
    onfatal(new Error("Expecting network key."))
  }

  if (null == argv.did) {
    onfatal(new Expecting("Expecting DID URI to resolve."))
  }

  if (0 == argv.did.indexOf('did:') && 0 != argv.did.indexOf('did:ara:')) {
    onfatal(new Error("Expecting a did URI with an 'ara' method."))
  }

  if (0 != argv.did.indexOf('did:ara:')) {
    argv.did = 'did:ara:' + argv.did
  }

  let { password } = await inquirer.prompt([{
    type: 'password',
    name: 'password',
    message:
    "Please provide a passphrase for your identity. This is needed to " +
    "archive your identity.\n" +
    "Passphrase:"
  }])

  if (!password) {
    onfatal(new TypeError("Please provide a password to archive your identity."))
  }

  password = crypto.blake2b(Buffer.from(password))

  const { identifier } = did.parse(argv.did)
  const hash = toHex(crypto.blake2b(Buffer.from(identifier, 'hex')))
  const path = resolve(rc.network.identity.root, hash)
  const identity = protobuf.messages.Identity.decode(
    await pify(fs.readFile)(resolve(path, 'identity'))
  )

  try {
    const doc = await secrets.load(argv)
    if (null == doc || (null == doc.public && null == doc.secret)) {
      onfatal(new TypeError("Unknown network key."))
    }

    const { keystore } = (doc.public || doc.secret)
    const { key } = argv
    const keys = JSON.parse(await pify(fs.readFile)(resolve(path, 'keys'), 'utf8'))
    const secretKey = crypto.decrypt(keys, {key: password.slice(0, 16)})
    const publicKey = secretKey.slice(32)
    const { files } = identity

    files.push({
      path: 'identity',
      buffer: protobuf.messages.Identity.encode(identity)
    })

    files.push({
      path: 'keys',
      buffer: JSON.stringify(keys)
    })

    files.push({
      path: 'schema.proto',
      buffer: protobuf.kProtocolBufferSchema,
    })

    warn("Archiving new identity for network '%s'.", key)
    await aid.archive({ publicKey, secretKey, files }, { keystore, key })
  } catch (err) {
    error("Possible incorrect password.")
    onfatal(err)
  }
}

async function oncreate(argv) {

  const { password } = await inquirer.prompt([{
    type: 'password',
    name: 'password',
    message:
    "Your identity's keystore will be secured by a passphrase. " +
    "Please provide a passphrase. Do not forget this as it will never be " +
    "shown to you.\n"+
    "Passphrase:"
  }])

  const identity = await aid.create({ context, password })

  info("New identity: %s", identity.did)

  const hash = toHex(crypto.blake2b(identity.publicKey))
  const output = resolve(rc.network.identity.root, hash)

  await pify(mkdirp)(output)

  for (let i = 0; i < identity.files.length; ++i) {
    warn("Writing %s",  resolve(output, identity.files[i].path))
    const dir = dirname(resolve(output, identity.files[i].path))
    await pify(mkdirp)(dir)
    await pify(fs.writeFile)(
      resolve(output, identity.files[i].path),
      identity.files[i].buffer)
  }

  if (argv.archive) {
    if (null == argv.key) {
      onfatal(new Error("Expecting network key."))
    }

    const doc = await secrets.load(argv)
    if (null == doc || (null == doc.public && null == doc.secret)) {
      onfatal(new TypeError("Unknown network key."))
    }

    const { keystore } = (doc.public || doc.secret)
    const { key } = argv
    warn("Archiving new identity for network '%s'.", key)
    await aid.archive(identity, { keystore, key })
  }
}

async function onimport(argv) {
  if (null == argv.key) {
    onfatal(new Error("Expecting network key."))
  }

  if (null == argv.did) {
    onfatal(new Expecting("Expecting DID URI to resolve."))
  }

  if (0 == argv.did.indexOf('did:') && 0 != argv.did.indexOf('did:ara:')) {
    onfatal(new Error("Expecting a did URI with an 'ara' method."))
  }

  if (0 != argv.did.indexOf('did:ara:')) {
    argv.did = 'did:ara:' + argv.did
  }

  let { password } = await inquirer.prompt([{
    type: 'password',
    name: 'password',
    message:
    "Do you own this identity? Please provide a password if you do.\n" +
    "Passphrase:"
  }])

  if (password) {
    password = crypto.blake2b(Buffer.from(password))
  }

  try {
    const doc = await secrets.load(argv)
    let publicKey = null
    let secretKey = null
    let keystore = null

    if (doc.public) { keystore = doc.public.keystore }
    else if (doc.secret) { keystore = doc.secret.keystore }

    if (password) {
      const keyPair = crypto.keyPair(password)
      publicKey = keyPair.publicKey
      secret = keyPair.secretKey
    } else {
      publicKey = identifier
    }

    const cfs = await createCFS({
      storage: ram,
      shallow: true,
      key: publicKey,
      id: toHex(publicKey),
    })

    const { identifier } = did.parse(argv.did)
    const hash = toHex(crypto.blake2b(Buffer.from(identifier, 'hex')))
    const output = resolve(rc.network.identity.root, hash)

    const discovery = createSwarm({
      dns: { loopback: true, multicast: true },
      stream() {
        const stream = cfs.replicate({live: false})
        stream.once('end', onend)
        return stream
      }
    })

    discovery.join(cfs.discoveryKey)
    cfs.once('update', onsync)

    async function onsync() {
      const files = await cfs.readdir('.')
      const state = {skips: 0, puts: 0}
      const partition = cfs.partitions.resolve('/home')
      mirror({name: '/', fs: partition}, {name: output, fs})
        .on('skip', () => { state.skips++ })
        .on('put', () => { state.puts++ })
        .on('end', onend)
    }

    function onend() {
      cfs.close()
      discovery.destroy()
    }

  } catch (err) {
    onfatal(err)
  }
}

async function onkeys(argv) {
  if (null == argv.did) {
    onfatal(new Expecting("Expecting DID URI to resolve."))
  }

  if (0 == argv.did.indexOf('did:') && 0 != argv.did.indexOf('did:ara:')) {
    onfatal(new Error("Expecting a did URI with an 'ara' method."))
  }

  if (0 != argv.did.indexOf('did:ara:')) {
    argv.did = 'did:ara:' + argv.did
  }

  const { identifier } = did.parse(argv.did)
  const hash = toHex(crypto.blake2b(Buffer.from(identifier, 'hex')))
  const path = resolve(rc.network.identity.root, hash)

  try { await pify(fs.access)(resolve(path, 'keys')) }
  catch (err) { onfatal(new Error(err.message)) }

  const keys = await pify(fs.readFile)(resolve(path, 'keys', ), 'utf8')
  console.log(keys);
}

async function onresolve(argv) {
  if (null == argv.did) {
    onfatal(new Expecting("Expecting DID URI to resolve."))
  }

  if (0 == argv.did.indexOf('did:') && 0 != argv.did.indexOf('did:ara:')) {
    onfatal(new Error("Expecting a did URI with an 'ara' method."))
  }

  if (0 != argv.did.indexOf('did:ara:')) {
    argv.did = 'did:ara:' + argv.did
  }

  try {
    let keystore = null
    if (argv.key) {
      const doc = await secrets.load(argv)
      if (doc.public) { keystore = doc.public.keystore }
      else if (doc.secret) { keystore = doc.secret.keystore }
    }

    const identity = await aid.resolve(argv.did, { context, keystore,
      timeout: argv.timeout,
      key: argv.key,
      cache: argv['no-cache']
        ? false : argv.cache
          ? true : false === argv.cache ?
            false : undefined,
    })
    console.log(JSON.stringify(identity))
  } catch (err) {
    onfatal(err)
  }
}

async function onlist(argv) {
  try{
    const identities = await aid.list(argv.path)
    info("Identities:")
    identities.forEach((id) => {
      console.log(id)
    })
  }
  catch(err) {
    onfatal(err)
  }
}

function onfatal(err) {
  debug(err)
  error("fatal:", err.message)
  process.exit(1)
}
