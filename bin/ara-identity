#!/usr/bin/env node

const { info, warn, error } = require('ara-console')
const { basename, resolve } = require('path')
const inquirer = require('inquirer')
const context = require('ara-context')()
const program = require('yargs')
const debug = require('debug')('ara:identity')
const pify = require('pify')
const aid = require('../')
const rc = require('ara-runtime-configuration')()
const fs = require('fs')

const conf = rc.network && rc.network.identity ? rc.network.identity : {}
const noop = () => void 0
const $0 = basename(process.argv[1] || package.name)

const { argv } = program
  .usage("$0 [-hDV] [...options] <command> [...options]")
  .option('force', {
    alias: 'f',
    type: 'boolean',
    describe: "Force actions without prompt",
  })
  .option('debug', {
    type: 'boolean',
    alias: 'D',
    describe: "Enable debug output",
  })
  .option('help', {
    alias: 'h',
    describe: "Show this help message"
  })
  .option('version', {
    alias: 'V',
    describe: "Show program version"
  })
  .option('keys', {
    alias: 'K',
    type: 'string',
    describe: "Directory containing keystores",
    default: conf.keys,
  })
  .option('key', {
    alias: 'k',
    type: 'string',
    describe: "Network key name",
    default: conf.key,
  })
  .option('output', {
    alias: 'o',
    type: 'string',
    describe: "Output file name",
    default: 'identity',
  })
  .command('create', "Create an identity", noop, oncreate)
  .command('resolve [did]', "Resolve an identity",
    (program) => {
      program.positional('did', {
        type: 'string',
        describe: "An ARA decentralized identity (did) URI"
      })
    }, onresolve)
  .command('stat', "Show stats about an identity file", noop, onstat)

process.on('unhandledRejection', onfatal)
process.on('uncaughtException', onfatal)

void async function main() {
  if (program.argv.debug) {
    require('debug').enable('ara:identity*')
  }
}()

async function oncreate(argv) {
  if (null == argv.key) {
    onfatal(new Error("Expecting network key."))
  }

  if (null == argv.keys) {
    onfatal(new Error("Expecting network keystore file path."))
  }

  const output = resolve(process.cwd(), argv.output)
  try {
    await pify(fs.access)(output)
    if (true !== argv.force) {
      const { overwrite } = await inquirer.prompt([{
        type: 'confirm',
        name: 'overwrite',
        message: `Overwrite file (${output})?`,
        default: false,
      }])

      if (true !== overwrite) {
        return process.exit(1)
      }
    }
  } catch (err) { }

  const key = argv.key
  const stream = fs.createWriteStream(output)
  const keystorePath = resolve(
    process.cwd(), argv.keys, 'archiver', 'keystore.pub')

  try { await pify(fs.access)(keystorePath) }
  catch (err) {
    debug(err)
    onfatal(new Error(`Couldn't file keystore file: ${keystorePath}`))
  }

  warn("Reading keystore '%s'.", keystorePath)

  const { password } = await inquirer.prompt([
    { type: 'password',
      name: 'password',
      message:
      "Your identity's Ethereum keystore will be secured by a passphrase. " +
      "Please provide a passphrase. Do not forget this as it will never be " +
      "shown to you.\n"+
      "Passphrase:" }
  ])

  warn("Creating new identity for network '%s'.", argv.key)
  const secrets = await pify(fs.readFile)(keystorePath)
  const { keystore } = JSON.parse(secrets)

  const identity = await aid.create({
    context, password, archive: { keystore, key },
  })

  info("New: %s", identity.did)
  info("Try: ara resolve %s", identity.did)
  stream.write(identity.buffer)
}

async function onresolve(argv) {
  if (null == argv.key) {
    onfatal(new Error("Expecting network key."))
  }

  if (null == argv.keys) {
    onfatal(new Error("Expecting network keystore file path."))
  }

  if (null == argv.did) {
    onfatal(new Expecting("Expecting DID URI to resolve."))
  }

  if (0 == argv.did.indexOf('did:') && 0 != argv.did.indexOf('did:ara:')) {
    onfatal(new Error("Expecting a did URI with an 'ara' method."))
  }

  if (0 != argv.did.indexOf('did:ara:')) {
    argv.did = 'did:ara:' + argv.did
  }

  const keystorePath = resolve(process.cwd(), argv.keys, 'resolver', 'keystore.pub')

  try {
    const key = argv.key
    const secrets = await pify(fs.readFile)(keystorePath)
    const { keystore } = JSON.parse(secrets)
    const identity = await aid.resolve(argv.did, { context, keystore, key })
    console.log(JSON.stringify(identity))
  } catch (err) {
    onfatal(err)
  }

}

async function onstat(argv) {
}

function onfatal(err) {
  debug(err)
  error("fatal:", err.message)
  process.exit(1)
}
