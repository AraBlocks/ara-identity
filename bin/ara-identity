#!/usr/bin/env node

const { info, warn, error } = require('ara-console')
const { basename, resolve } = require('path')
const identitySecrets = require('../secrets')
const { toHex } = require('../util')
const protobuf = require('../protobuf')
const inquirer = require('inquirer')
const context = require('ara-context')()
const program = require('yargs')
const secrets = require('ara-network/secrets')
const crypto = require('ara-crypto')
const extend = require('extend')
const mkdirp = require('mkdirp')
const debug = require('debug')('ara:identity')
const pify = require('pify')
const did = require('did-uri')
const aid = require('../')
const fs = require('fs')
const os = require('os')
const rc = require('../rc')()

const noop = () => void 0
const $0 = basename(process.argv[1] || package.name)

process.on('unhandledRejection', onfatal)
process.on('uncaughtException', onfatal)

const { argv } = program
  .usage("$0 [-hDV] [...options] <command> [...options]")
  .option('debug', {
    type: 'boolean',
    alias: 'D',
    describe: "Enable debug output",
  })
  .option('help', {
    alias: 'h',
    describe: "Show this help message"
  })
  .option('version', {
    alias: 'V',
    describe: "Show program version"
  })
  .option('force', {
    alias: 'f',
    type: 'boolean',
    describe: "Force actions without prompt",
  })
  .option('key', {
    alias: 'k',
    type: 'string',
    describe: "Network key name",
  })
  .command('create', "Create an identity", (program) => {
    program
      .option('archive', {
        alias: 'A',
        type: 'boolean',
        describe: "Archive identity into network",
      })
  }, oncreate)
  .command('resolve [did]', "Resolve an identity", (program) => {
    program
      .positional('did', {
        type: 'string',
        describe: "An ARA decentralized identity (did) URI"
      })
      .option('cache', {
        alias: 'C',
        type: 'boolean',
        describe: "Enable or disable cache",
      })
      .option('no-cache', {
        type: 'boolean',
        describe: "Disable cache",
      })
      .option('cache', {
        alias: 'A',
        type: 'boolean',
        describe: "Skip identity cache",
      })
      .option('timeout', {
        alias: 't',
        type: 'number',
        describe: "Resolution timeout",
      })
  }, onresolve)
  .command('archive [did]', "Archive identity in network", (program) => {
    program
      .positional('did', {
        type: 'string',
        describe: "An ARA decentralized identity (did) URI"
      })
  }, onarchive)

void async function main() {
  if (program.argv.debug) {
    require('debug').enable('ara:identity*')
  }
}()

async function oncreate(argv) {

  const { password } = await inquirer.prompt([{
    type: 'password',
    name: 'password',
    message:
    "Your identity's Ethereum keystore will be secured by a passphrase. " +
    "Please provide a passphrase. Do not forget this as it will never be " +
    "shown to you.\n"+
    "Passphrase:"
  }])

  const identity = await aid.create({ context, password })

  info("New identity: %s", identity.did)

  const hash = toHex(crypto.blake2b(identity.publicKey))
  const output = resolve(rc.network.identity.root, hash)

  await pify(mkdirp)(output)

  for (let i = 2; i < identity.files.length; ++i) {
    warn("Writing %s",  resolve(output, identity.files[i].path))
    await pify(fs.writeFile)(
      resolve(output, identity.files[i].path),
      identity.files[i].buffer)
  }

  if (argv.archive) {
    if (null == argv.key) {
      onfatal(new Error("Expecting network key."))
    }

    const doc = await secrets.load(argv)
    if (null == doc) {
      throw new TypeError("Unknown network key")
    }

    const { keystore } = (doc.public || doc.secret)
    const { key } = argv
    warn("Archiving new identity for network '%s'.", key)
    await aid.archive(identity, { keystore, key })
  }
}

async function onresolve(argv) {
  if (null == argv.key) {
    onfatal(new Error("Expecting network key."))
  }

  if (null == argv.did) {
    onfatal(new Expecting("Expecting DID URI to resolve."))
  }

  if (0 == argv.did.indexOf('did:') && 0 != argv.did.indexOf('did:ara:')) {
    onfatal(new Error("Expecting a did URI with an 'ara' method."))
  }

  if (0 != argv.did.indexOf('did:ara:')) {
    argv.did = 'did:ara:' + argv.did
  }

  try {
    const doc = await secrets.load(argv)
    let keystore = null
    if (doc.public) { keystore = doc.public.keystore }
    else if (doc.secret) { keystore = doc.public.keystore }
    const identity = await aid.resolve(argv.did, { context, keystore,
      timeout: argv.timeout,
      cache: argv['no-cache'] ? false : argv.cache ? true : false,
      key: argv.key,
    })
    console.log(JSON.stringify(identity))
  } catch (err) {
    onfatal(err)
  }

}

async function onarchive(argv) {
  if (null == argv.key) {
    onfatal(new Error("Expecting network key."))
  }

  if (null == argv.did) {
    onfatal(new Expecting("Expecting DID URI to resolve."))
  }

  if (0 == argv.did.indexOf('did:') && 0 != argv.did.indexOf('did:ara:')) {
    onfatal(new Error("Expecting a did URI with an 'ara' method."))
  }

  if (0 != argv.did.indexOf('did:ara:')) {
    argv.did = 'did:ara:' + argv.did
  }

  let { password } = await inquirer.prompt([{
    type: 'password',
    name: 'password',
    message:
    "Your identity's Ethereum keystore will be secured by a passphrase. " +
    "Please provide a passphrase. Do not forget this as it will never be " +
    "shown to you.\n"+
    "Passphrase:"
  }])

  password = crypto.blake2b(Buffer.from(password))

  const { identifier } = did.parse(argv.did)
  const hash = toHex(crypto.blake2b(Buffer.from(identifier, 'hex')))
  const path = resolve(rc.network.identity.root, hash)
  const identity = protobuf.messages.Identity.decode(
    await pify(fs.readFile)(resolve(path, 'identity'))
  )

  try {
    const doc = await secrets.load(argv)
    if (null == doc) {
      throw new TypeError("Unknown network key")
    }

    const { keystore } = (doc.public || doc.secret)
    const { key } = argv
    const keys = JSON.parse(await pify(fs.readFile)(resolve(path, 'keys'), 'utf8'))
    const keyPair = identitySecrets.decrypt(keys, password)
    const { files } = identity
    const { publicKey, secretKey } = keyPair.keys[0]

    files.push({
      path: 'identity',
      buffer: protobuf.messages.Identity.encode(identity)
    })

    files.push({
      path: 'keys',
      buffer: JSON.stringify(keys)
    })

    warn("Archiving new identity for network '%s'.", key)
    await aid.archive({ publicKey, secretKey, files }, { keystore, key })
  } catch (err) {
    error("Possible incorrect password.")
    onfatal(err)
  }
}

function onfatal(err) {
  debug(err)
  error("fatal:", err.message)
  process.exit(1)
}
