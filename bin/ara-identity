#!/usr/bin/env node

const { info, warn, error } = require('ara-console')
const { unpack, keyRing } = require('ara-network/keys')
const { writeIdentity } = require('../util')
// const { createCFS } = require('cfsnet/create')
const { resolve } = require('path')
const { toHex } = require('../util')
const { table } = require('table')
const protobuf = require('../protobuf')
const inquirer = require('inquirer')
const context = require('ara-context')()
const program = require('yargs')
const crypto = require('ara-crypto')
// const mirror = require('mirror-folder')
const debug = require('debug')('ara:identity')
const pify = require('pify')
const did = require('did-uri')
const aid = require('../')
// const ram = require('random-access-memory')
const fs = require('fs')
const rc = require('../rc')()
const ss = require('ara-secret-storage')

process.on('unhandledRejection', onfatal)
process.on('uncaughtException', onfatal)

program
  .usage('usage: $0 [-hDV] [options] <command> [options]')
  .option('debug', {
    type: 'boolean',
    alias: 'D',
    describe: 'Enable debug output',
  })
  .option('force', {
    alias: 'f',
    type: 'boolean',
    describe: 'Force actions without prompt',
  })
  .option('help', {
    alias: 'h',
    describe: 'Show this help message'
  })
  .option('key', {
    alias: 'k',
    type: 'string',
    describe: 'Network key name',
  })
  .option('version', {
    alias: 'V',
    describe: 'Show program version'
  })
  .command(
    'archive [did]',
    'Archive identity in network',
    // eslint-disable-next-line no-shadow
    program => program
      .positional('did', {
        type: 'string',
        describe: 'An ARA decentralized identity (did) URI'
      })
      .option('secret', {
        alias: 's',
        describe: 'shared network secret string'
      })
      .option('key', {
        alias: 'k',
        type: 'string',
        describe: 'shared network public key',
      })
      .option('name', {
        alias: 'n',
        describe: 'Human readable network keys name'
      })
    , onarchive
  )
  .command(
    'create',
    'Create an identity',
    // eslint-disable-next-line no-shadow
    program => program
      .option('archive', {
        alias: 'A',
        type: 'boolean',
        describe: 'Archive identity into network',
      })
    , oncreate
  )
  .command(
    'resolve [did]',
    'Resolve an identity',
    // eslint-disable-next-line no-shadow
    program => program
      .option('secret', {
        alias: 's',
        describe: 'Shared secret key for the associated network keys.'
      })
      .option('name', {
        alias: 'n',
        describe: 'Human readable network keys name.'
      })
      .option('keys', {
        alias: 'k',
        describe: 'Path to ARA network keys'
      })
      .option('cache', {
        alias: 'C',
        type: 'boolean',
        describe: 'Enable or disable cache',
        default: true
      })
      .option('no-cache', {
        alias: 'nocache',
        type: 'boolean',
        describe: 'Skip identity cache',
      })
      .option('timeout', {
        alias: 't',
        type: 'number',
        describe: 'Resolution timeout',
      })
    , onresolve
  )
  .command(
    'list',
    'Outputs a list of all identities created locally',
    // eslint-disable-next-line no-shadow
    program => program
      .option('path', {
        alias: 'p',
        type: 'string',
        describe: 'Path to look for identities (Optional)'
      })
    , onlist
  )

if (0 === program.argv._.length) {
  program.showHelp()
  process.exit(1)
}

if (program.argv.debug) {
  // eslint-disable-next-line global-require
  require('debug').enable('ara:identity*')
}

async function onarchive(argv) {

  if (!argv.key) {
    onfatal(new TypeError('Expecting network key.'))
  }

  if (!argv.did) {
    onfatal(new TypeError('Expecting DID URI to resolve.'))
  }

  if (0 === argv.did.indexOf('did:') && 0 !== argv.did.indexOf('did:ara:')) {
    onfatal(new Error('Expecting a did URI with an \'ara\' method.'))
  }

  if (0 !== argv.did.indexOf('did:ara:')) {
    // eslint-disable-next-line no-param-reassign
    argv.did = `did:ara:${argv.did}`
  }

  let { password } = await inquirer.prompt([ {
    type: 'password',
    name: 'password',
    message:
    'Please provide a passphrase for your identity. This is needed to ' +
    'archive your identity.\n' +
    'Passphrase:'
  } ])

  if (!password) {
    // eslint-disable-next-line function-paren-newline
    onfatal(
      new TypeError('Please provide a password to archive your identity.'))
  }

  password = crypto.blake2b(Buffer.from(password))

  const { identifier } = did.parse(argv.did)
  const hash = toHex(crypto.blake2b(Buffer.from(identifier, 'hex')))
  const path = resolve(rc.network.identity.root, hash)
  const identityBuffer = await pify(fs.readFile)(resolve(path, 'identity'))
  const identity = protobuf.messages.Identity.decode(identityBuffer)

  void identity

  try {

    const { secret, key, name  } = argv
    const keystorePath = resolve(path, 'keystore/ara')
    const keystoreBuffer = await pify(fs.readFile)(keystorePath, 'utf8')
    const keys = JSON.parse(String(keystoreBuffer))
    const secretKey = ss.decrypt(keys, { key: password.slice(0, 16) })
    const publicKey = secretKey.slice(32)
    const { files } = identity

    // manually construct identity file for archiver
    files.push({ path: 'identity', buffer: identityBuffer })

    await aid.archive({ publicKey, secretKey, files }, { secret, key, name })
  } catch (err) {
    error('Possible incorrect password.')
    onfatal(err)
  }
}

async function oncreate() {
  const { password } = await inquirer.prompt([ {
    type: 'password',
    name: 'password',
    message:
    'Your identity\'s keystore will be secured by a passphrase. \n' +
    'Please provide a passphrase. Do not forget this as it will never be ' +
    'shown to you.\n' +
    'Passphrase:'
  } ])

  process.stdout.write('\n')
  const identity = await aid.create({ context, password })

  info('New identity created: %s', identity.did)

  for (let i = 0; i < identity.files.length; ++i) {
    warn('Will write identity file: %s', identity.files[i].path)
  }

  await writeIdentity(identity)

  info('Please safely store the following 12 word mnemonic phrase for this')
  info('ARA ID. This phrase will be required to restore your ARA ID.')
  info('It will never be shown again:')
  info('\n\n%s', table([ [ identity.mnemonic ] ]))
}

async function onresolve(argv) {
  if (!argv.did) {
    onfatal(new TypeError('Expecting DID URI to resolve.'))
  }

  if (0 === argv.did.indexOf('did:') && 0 !== argv.did.indexOf('did:ara:')) {
    onfatal(new Error('Expecting a did URI with an \'ara\' method.'))
  }

  if (0 !== argv.did.indexOf('did:ara:')) {
    // eslint-disable-next-line no-param-reassign
    argv.did = `did:ara:${argv.did}`
  }

  try {
    const { timeout, key } = argv

    let cache
    let keys = null

    if (argv['no-cache'] || argv.nocache || false === argv.cache) {
      cache = false
    } else if (true === argv.cache) {
      cache = true
    }

    if (argv.secret && argv.keys) {
      const secret = Buffer.from(argv.secret)
      const keyring = keyRing(argv.keys, { secret })
      await keyring.ready()
      const buffer = await keyring.get(argv.name)
      keys = unpack({ buffer })
    }

    const identity = await aid.resolve(argv.did, {
      context,
      timeout,
      cache,
      keys,
      key,
    })

    process.stdout.write(JSON.stringify(identity))
  } catch (err) {
    onfatal(err)
  }
}

async function onlist(argv) {
  try {
    debug('aid: list: %s', argv.path)

    const identities = await aid.list(argv.path)

    debug('aid: list: %d identities', identities.length)
    for (const id of identities) {
      process.stdout.write(`${id}\n`)
    }
  } catch (err) {
    onfatal(err)
  }
}

function onfatal(err) {
  debug(err)
  error('fatal:', err.message)
  process.exit(1)
}
