#!/usr/bin/env node

const { info, warn, error } = require('ara-console')
const { writeIdentity } = require('../util')
// const { createCFS } = require('cfsnet/create')
const { resolve } = require('path')
const { toHex } = require('../util')
const { table } = require('table')
const protobuf = require('../protobuf')
const inquirer = require('inquirer')
const context = require('ara-context')()
const program = require('yargs')
const crypto = require('ara-crypto')
// const mirror = require('mirror-folder')
const debug = require('debug')('ara:identity')
const pify = require('pify')
const did = require('did-uri')
const aid = require('../')
// const ram = require('random-access-memory')
const fs = require('fs')
const rc = require('../rc')()
const ss = require('ara-secret-storage')

process.on('unhandledRejection', onfatal)
process.on('uncaughtException', onfatal)

const ellipsis = (s, x, y) => s.slice(x || 0, y || 4)

program
  .usage('usage: $0 [-hDV] <command> [options]')
  .wrap(null)

program
  .group([ 'help', 'debug', 'version' ], 'General Options:')
  .option('help', {
    alias: 'h',
    describe: 'Show this help message',
  })
  .option('debug', {
    alias: 'D',
    describe: 'Enable debug output',
  })
  .option('version', {
    alias: 'V',
    describe: 'Show program version'
  })

program.command(
  'create',
  'Create an identity',
  // eslint-disable-next-line no-shadow
  program => program
    .usage('usage: $0 [-D] create [options]')
  , oncreate
)

program.command(
  'archive [did]',
  'Archive identity in network',
  // eslint-disable-next-line no-shadow
  program => program
    .usage('usage: $0 [-D] archive [options]')
    .positional('did', {
      default: rc.network.identity.whoami,
    })
    .group([ 'secret', 'keyring', 'network' ], 'Network Options:')
    .option('secret', {
      alias: 's',
      describe: 'Shared secret key for the associated network keys',
      required: true,
      requiresArg: true,
    })
    .option('keyring', {
      alias: 'k',
      default: rc.network.identity.keyring,
      describe: 'Path to Ara network keyring file',
      required: true,
      requiresArg: true,
    })
    .option('network', {
      alias: 'n',
      describe: 'Human readable network name for keys in keyring',
      required: true,
      requiresArg: true,
    })
  , onarchive
)

program.command(
  'resolve [did]',
  'Resolve an identity',
  // eslint-disable-next-line no-shadow
  program => program
    .usage('usage: $0 [-hDV] resolve [options]')
    .positional('did', {
      default: rc.network.identity.whoami,
    })
    .group([ 'secret', 'keyring', 'network' ], 'Network Options:')
    .option('secret', {
      alias: 's',
      describe: 'Shared secret key for the associated network keys.',
      requiresArg: true,
    })
    .option('network', {
      alias: 'n',
      describe: 'Human readable network name for keys in keyring',
      requiresArg: true,
    })
    .option('keyring', {
      alias: 'k',
      default: rc.network.identity.keyring,
      describe: 'Path to Ara network keyring file',
      requiresArg: true,
    })
    .group([ 'cache', 'timeout' ], 'Resolution Options:')
    .option('cache', {
      type: 'boolean',
      alias: 'C',
      describe: 'Enable or disable cache',
      default: true,
    })
    .option('timeout', {
      alias: 't',
      describe: 'Resolution timeout',
    })
  , onresolve
)

program.command(
  'list',
  'Output local identities',
  // eslint-disable-next-line no-shadow
  program => program
    .usage('usage: $0 [-D] list [options]')
    .group([ 'path' ], 'List Options:')
    .option('path', {
      alias: 'p',
      describe: 'Path to look for identities',
      optional: true
    })
  , onlist
)

program.command(
  'whoami',
  'Output current Ara identity in context (.ararc)',
  // eslint-disable-next-line no-shadow
  program => program
    .usage('usage: $0 [-D] whoami')
  , onwhoami
)

program.command(
  'recover',
  'Recover an Ara identity using a mnemonic',
  // eslint-disable-next-line no-shadow
  program => program
    .usage('usage: $0 [-D] recover')
    .group([ 'mnemonic' ], 'Recovery Options:')
    .option('mnemonic', {
      alias: 'm',
      describe: 'Valid bip39 mnemonic',
      required: true,
      requiresArg: true,
    })
  , onrecover
)

program
  .recommendCommands()
  .completion('completion', false)

void program.getOptions().boolean.splice(-2)

if (0 === program.argv._.length) {
  program.showHelp()
  process.exit(1)
}

if (program.argv.debug) {
  // eslint-disable-next-line global-require
  require('debug').enable('ara:identity*')
}

async function onrecover(argv) {
  const { mnemonic } = argv

  let { password } = await inquirer.prompt([ {
    type: 'password',
    name: 'password',
    message:
    'Please provide a new passphrase for the identity being recovered. This would be needed to ' +
    'archive your recovered identity.\n' +
    'Passphrase:'
  } ])

  if (!password) {
    // eslint-disable-next-line function-paren-newline
    onfatal(
      new TypeError('A new passphrase is required to recover the identity.'))
  }

  try {
    const identity = await aid.recover({ context, password, mnemonic })
    info('Identity recovered : %s', identity.did)

    for (let i = 0; i < identity.files.length; ++i) {
      warn('Will write identity file: %s', identity.files[i].path)
    }

    await writeIdentity(identity)
    info('Identity recovered successfully.')
  } catch (err) {
    onfatal(err)
  }

  process.exit(0)
}

async function onarchive(argv) {
  if (0 === argv.did.indexOf('did:') && 0 !== argv.did.indexOf('did:ara:')) {
    onfatal(new Error('Expecting a did URI with an \'ara\' method.'))
  }

  if (0 !== argv.did.indexOf('did:ara:')) {
    // eslint-disable-next-line no-param-reassign
    argv.did = `did:ara:${argv.did}`
  }

  let { password } = await inquirer.prompt([ {
    type: 'password',
    name: 'password',
    message:
    'Please provide a passphrase for your identity. This is needed to ' +
    'archive your identity.\n' +
    'Passphrase:'
  } ])

  if (!password) {
    // eslint-disable-next-line function-paren-newline
    onfatal(
      new TypeError('Please provide a password to archive your identity.'))
  }

  password = crypto.blake2b(Buffer.from(password))

  const { identifier } = did.parse(argv.did)
  const hash = toHex(crypto.blake2b(Buffer.from(identifier, 'hex')))
  const path = resolve(rc.network.identity.root, hash)
  const identityBuffer = await pify(fs.readFile)(resolve(path, 'identity'))
  const identity = protobuf.messages.Identity.decode(identityBuffer)

  const stats = {
    totalConnections: 0
  }

  try {
    const { keyring, network, secret } = argv
    const keystorePath = resolve(path, 'keystore/ara')
    const keystoreBuffer = await pify(fs.readFile)(keystorePath, 'utf8')
    const keystore = JSON.parse(String(keystoreBuffer))

    let secretKey = null
    let publicKey = null

    try {
      secretKey = ss.decrypt(keystore, { key: password.slice(0, 16) })
      publicKey = secretKey.slice(32)
    } catch (err) {
      debug(err)
      onfatal(new Error('Invalid passphrase when decoding keystore.'))
    }

    const { files } = identity

    // manually construct identity file for archiver
    files.push({
      path: 'identity',
      buffer: identityBuffer
    })

    warn('Archiving new identity for network \'%s\'.', keyring)
    const didArchive = await aid.archive({
      publicKey,
      secretKey,
      files
    }, {
      network,
      secret,
      keyring,

      onhello,
      onauth,
      onokay,

      onclose,
      onerror,
    })

    info(
      '%d connection%s made',
      stats.totalConnections,
      1 === stats.totalConnections ? '' : 's',
    )

    if (didArchive) {
      info('Successfully archived identity to network "%s"', network)
      process.nextTick(() => process.exit(0))
    } else {
      error('Failed to archive identity')
      process.nextTick(() => process.exit(1))
    }
  } catch (err) {
    onfatal(err)
  }

  function onhello(hello) {
    info(
      'Got hello from archiver node: key=%s mac=%s',
      toHex(ellipsis(hello.publicKey)),
      toHex(ellipsis(hello.mac)),
    )
  }

  function onauth(auth) {
    info(
      'Authenticated with archiver node: keys=%s signature=%s',
      toHex(ellipsis(auth.publicKey)),
      toHex(ellipsis(auth.signature)),
    )
  }

  function onokay(okay) {
    info(
      'Got okay from archiver node: signature=%s',
      toHex(ellipsis(okay)),
    )
  }

  function onclose(rinfo) {
    stats.totalConnections = rinfo.totalConnections
    warn(
      'Connection #%d to %s:%s@%s closed.',
      rinfo.peerIndex,
      rinfo.peer.host,
      rinfo.peer.port,
      toHex(ellipsis(rinfo.discoveryKey)),
    )
  }

  function onerror(err) {
    debug(err.stack || err)
    error('Got error in archiver:', err.message)
    process.nextTick(() => process.exit(1))
  }
}

async function oncreate() {
  const { password } = await inquirer.prompt([ {
    type: 'password',
    name: 'password',
    message:
    'Your identity\'s keystore will be secured by a passphrase. \n' +
    'Please provide a passphrase. Do not forget this as it will never be ' +
    'shown to you.\n' +
    'Passphrase:'
  } ])

  process.stdout.write('\n')
  const identity = await aid.create({ context, password })

  info('New identity created: %s', identity.did)

  for (let i = 0; i < identity.files.length; ++i) {
    warn('Will write identity file: %s', identity.files[i].path)
  }

  await writeIdentity(identity)

  info('Please safely store the following 12 word mnemonic phrase for this')
  info('Ara ID. This phrase will be required to restore your Ara ID.')
  info('It will never be shown again:')
  info('\n\n%s', table([ [ identity.mnemonic ] ]))

  process.exit(0)
}

async function onresolve(argv) {
  if (!argv.keyring && !argv.cache) {
    onfatal(new TypeError('Expecting Ara network keyring file.'))
  }

  if (!argv.secret && !argv.cache) {
    onfatal(new TypeError('Expecting Shared secret key.'))
  }

  if (!argv.network && !argv.cache) {
    onfatal(new TypeError('Expecting Human readable network keys name.'))
  }

  if (0 === argv.did.indexOf('did:') && 0 !== argv.did.indexOf('did:ara:')) {
    onfatal(new Error('Expecting a did URI with an \'ara\' method.'))
  }

  if (0 !== argv.did.indexOf('did:ara:')) {
    // eslint-disable-next-line no-param-reassign
    argv.did = `did:ara:${argv.did}`
  }

  try {
    let cache

    const {
      timeout,
      keyring,
      network,
      secret,
    } = argv

    if (argv['no-cache'] || argv.nocache || false === argv.cache) {
      cache = false
    } else if (true === argv.cache) {
      cache = true
    }

    const identity = await aid.resolve(argv.did, {
      network,
      keyring,
      timeout,
      secret,
      cache,
    })

    process.stdout.write(JSON.stringify(identity))
  } catch (err) {
    onfatal(err)
  }

  process.exit(0)
}

async function onlist(argv) {
  try {
    debug('aid: list: %s', argv.path)

    const identities = await aid.list(argv.path)

    debug('aid: list: %d identities', identities.length)
    for (const id of identities) {
      process.stdout.write(`${id}\n`)
    }

    process.exit(0)
  } catch (err) {
    onfatal(err)
  }
}

async function onwhoami(argv) {
  void argv
  let identifier = null
  let uri = rc.network.identity.whoami

  if (uri && 0 !== uri.indexOf('did:ara:')) {
    // eslint-disable-next-line no-param-reassign
    uri = `did:ara:${uri}`
  }

  if (!uri) {
    process.exit(1)
    return
  }

  try {
    // eslint-disable-next-line prefer-destructuring
    identifier = did.parse(uri).identifier
  } catch (err) {
    onfatal(new Error(`Failed to parse DID URI: ${uri}`))
  }

  try {
    const hash = toHex(crypto.blake2b(Buffer.from(identifier, 'hex')))
    const path = resolve(rc.network.identity.root, hash, 'ddo.json')
    const ddo = JSON.parse(await pify(fs.readFile)(path))

    if ('id' in ddo && ddo.id === uri) {
      process.stdout.write(ddo.id)
      process.stdout.write('\n')
      process.exit(0)
    } else {
      process.exit(1)
    }
  } catch (err) {
    debug(err)
    process.exit(1)
  }
}

function onfatal(err) {
  debug(err)
  error('fatal:', err.message)
  process.exit(1)
}
