#!/usr/bin/env node

const { info, warn, error } = require('ara-console')
const { writeIdentity } = require('../util')
// const { createCFS } = require('cfsnet/create')
const { resolve } = require('path')
const { toHex } = require('../util')
const { table } = require('table')
const protobuf = require('../protobuf')
const inquirer = require('inquirer')
const context = require('ara-context')()
const program = require('yargs')
const crypto = require('ara-crypto')
// const mirror = require('mirror-folder')
const debug = require('debug')('ara:identity')
const pify = require('pify')
const did = require('did-uri')
const aid = require('../')
// const ram = require('random-access-memory')
const fs = require('fs')
const rc = require('../rc')()
const ss = require('ara-secret-storage')

process.on('unhandledRejection', onfatal)
process.on('uncaughtException', onfatal)

program
  .usage('usage: $0 [-hDfV] [options] <command> [options]')
  .option('D', {
    type: 'boolean',
    alias: 'debug',
    describe: 'Enable debug output',
  })
  .option('f', {
    alias: 'force',
    type: 'boolean',
    describe: 'Force actions without prompt',
  })
  .option('h', {
    alias: 'help',
    describe: 'Show this help message'
  })
  .option('V', {
    alias: 'version',
    describe: 'Show program version'
  })
  .command(
    'archive [did]',
    'Archive identity in network',
    // eslint-disable-next-line no-shadow
    program => program
      .positional('did', {
        type: 'string',
        default: rc.network.identity.whoami,
        describe: 'An Ara decentralized identity (DID) URI',
        required: true,
      })
      .option('s', {
        alias: 'secret',
        describe: 'Shared secret key for the associated network keys'
      })
      .option('k', {
        alias: 'keyring',
        type: 'string',
        describe: 'Path to Ara network keyring file',
      })
      .option('n', {
        alias: 'name',
        describe: 'Human readable network keys name'
      })
    , onarchive
  )
  .command(
    'create',
    'Create an identity',
    // eslint-disable-next-line no-shadow
    program => program
      .option('A', {
        alias: 'archive',
        type: 'boolean',
        describe: 'Archive identity into network',
      })
    , oncreate
  )
  .command(
    'resolve [did]',
    'Resolve an identity',
    // eslint-disable-next-line no-shadow
    program => program
      .positional('did', {
        type: 'string',
        default: rc.network.identity.whoami,
        describe: 'An Ara decentralized identity (DID) URI',
        required: true,
      })
      .option('s', {
        alias: 'secret',
        describe: 'Shared secret key for the associated network keys.'
      })
      .option('n', {
        alias: 'name',
        describe: 'Human readable network keys name.'
      })
      .option('k', {
        alias: 'keyring',
        describe: 'Path to Ara network keyring file'
      })
      .option('C', {
        alias: 'cache',
        type: 'boolean',
        describe: 'Enable or disable cache',
        default: true
      })
      .option('no-cache', {
        alias: 'nocache',
        type: 'boolean',
        describe: 'Skip identity cache',
      })
      .option('t', {
        alias: 'timeout',
        type: 'number',
        describe: 'Resolution timeout',
      })
    , onresolve
  )
  .command(
    'list',
    'Output local identities',
    // eslint-disable-next-line no-shadow
    program => program
      .option('p', {
        alias: 'path',
        type: 'string',
        describe: 'Path to look for identities',
        optional: true
      })
    , onlist
  )
  .command(
    'whoami',
    'Output current Ara identity in context (.ararc)',
    // eslint-disable-next-line no-shadow
    program => program
    , onwhoami
  )

if (0 === program.argv._.length) {
  program.showHelp()
  process.exit(1)
}

if (program.argv.debug) {
  // eslint-disable-next-line global-require
  require('debug').enable('ara:identity*')
}

async function onarchive(argv) {
  if (!argv.keyring) {
    onfatal(new TypeError('Expecting network key.'))
  }

  if (!argv.secret) {
    onfatal(new TypeError('Expecting Shared secret key.'))
  }

  if (!argv.name) {
    onfatal(new TypeError('Expecting Human readable network keys name.'))
  }

  if (!argv.did) {
    onfatal(new TypeError('Please provide a DID to archive.'))
  }

  if (0 === argv.did.indexOf('did:') && 0 !== argv.did.indexOf('did:ara:')) {
    onfatal(new Error('Expecting a did URI with an \'ara\' method.'))
  }

  if (0 !== argv.did.indexOf('did:ara:')) {
    // eslint-disable-next-line no-param-reassign
    argv.did = `did:ara:${argv.did}`
  }

  let { password } = await inquirer.prompt([ {
    type: 'password',
    name: 'password',
    message:
    'Please provide a passphrase for your identity. This is needed to ' +
    'archive your identity.\n' +
    'Passphrase:'
  } ])

  if (!password) {
    // eslint-disable-next-line function-paren-newline
    onfatal(
      new TypeError('Please provide a password to archive your identity.'))
  }

  password = crypto.blake2b(Buffer.from(password))

  const { identifier } = did.parse(argv.did)
  const hash = toHex(crypto.blake2b(Buffer.from(identifier, 'hex')))
  const path = resolve(rc.network.identity.root, hash)
  const identityBuffer = await pify(fs.readFile)(resolve(path, 'identity'))
  const identity = protobuf.messages.Identity.decode(identityBuffer)

  void identity

  try {
    const { secret, keyring, name } = argv
    const keystorePath = resolve(path, 'keystore/ara')
    const keystoreBuffer = await pify(fs.readFile)(keystorePath, 'utf8')
    const keys = JSON.parse(String(keystoreBuffer))
    const secretKey = ss.decrypt(keys, { key: password.slice(0, 16) })
    const publicKey = secretKey.slice(32)
    const { files } = identity

    // manually construct identity file for archiver
    files.push({ path: 'identity', buffer: identityBuffer })
    warn('Archiving new identity for network \'%s\'.', keyring)
    await aid.archive({
      publicKey, secretKey, files
    }, {
      secret,
      keyring,
      name,

      onhello,
      onauth,
      onokay,

      onclose,
      onerror,
    })
  } catch (err) {
    error('Possible incorrect password.')
    onfatal(err)
  }

  function onhello(hello) {
    info(
      'Got hello from archiver node: key=%s mac=%s',
      hello.publicKey.toString('hex'),
      hello.mac.toString('hex'),
    )
  }

  function onauth(auth) {
    info(
      'Authenticated with archiver node: keys=%s signature=%s',
      auth.publicKey.toString('hex'),
      auth.signature.toString('hex'),
    )
  }

  function onokay(okay) {
    info(
      'Got okay from archiver node: signature=%s',
      okay.toString('hex'),
    )
  }

  function onclose() {
    info('Connection closed')
    process.nextTick(() => process.exit(0))
  }

  function onerror(err) {
    debug(err.stack || err)
    error('Got error in archiver:', err.message)
    process.nextTick(() => process.exit(1))
  }
}

async function oncreate() {
  const { password } = await inquirer.prompt([ {
    type: 'password',
    name: 'password',
    message:
    'Your identity\'s keystore will be secured by a passphrase. \n' +
    'Please provide a passphrase. Do not forget this as it will never be ' +
    'shown to you.\n' +
    'Passphrase:'
  } ])

  process.stdout.write('\n')
  const identity = await aid.create({ context, password })

  info('New identity created: %s', identity.did)

  for (let i = 0; i < identity.files.length; ++i) {
    warn('Will write identity file: %s', identity.files[i].path)
  }

  await writeIdentity(identity)

  info('Please safely store the following 12 word mnemonic phrase for this')
  info('Ara ID. This phrase will be required to restore your Ara ID.')
  info('It will never be shown again:')
  info('\n\n%s', table([ [ identity.mnemonic ] ]))

  process.exit(0)
}

async function onresolve(argv) {
  if (!argv.did) {
    onfatal(new TypeError('Expecting DID URI to resolve.'))
  }

  if (!argv.keyring && !argv.cache) {
    onfatal(new TypeError('Expecting Ara network keyring file.'))
  }

  if (!argv.secret && !argv.cache) {
    onfatal(new TypeError('Expecting Shared secret key.'))
  }

  if (!argv.name && !argv.cache) {
    onfatal(new TypeError('Expecting Human readable network keys name.'))
  }

  if (0 === argv.did.indexOf('did:') && 0 !== argv.did.indexOf('did:ara:')) {
    onfatal(new Error('Expecting a did URI with an \'ara\' method.'))
  }

  if (0 !== argv.did.indexOf('did:ara:')) {
    // eslint-disable-next-line no-param-reassign
    argv.did = `did:ara:${argv.did}`
  }

  try {
    const {
      timeout,
      keyring,
      secret,
      name
    } = argv

    let cache

    if (argv['no-cache'] || argv.nocache || false === argv.cache) {
      cache = false
    } else if (true === argv.cache) {
      cache = true
    }

    const identity = await aid.resolve(argv.did, {
      keyring,
      timeout,
      secret,
      cache,
      name,
    })

    process.stdout.write(JSON.stringify(identity))
  } catch (err) {
    onfatal(err)
  }

  process.exit(0)
}

async function onlist(argv) {
  try {
    debug('aid: list: %s', argv.path)

    const identities = await aid.list(argv.path)

    debug('aid: list: %d identities', identities.length)
    for (const id of identities) {
      process.stdout.write(`${id}\n`)
    }

    process.exit(0)
  } catch (err) {
    onfatal(err)
  }
}

async function onwhoami(argv) {
  void argv
  let identifier = null
  let uri = rc.network.identity.whoami

  if (uri && 0 !== uri.indexOf('did:ara:')) {
    // eslint-disable-next-line no-param-reassign
    uri = `did:ara:${uri}`
  }

  if (!uri) {
    process.exit(1)
    return
  }

  try {
    // eslint-disable-next-line prefer-destructuring
    identifier = did.parse(uri).identifier
  } catch (err) {
    onfatal(new Error(`Failed to parse DID URI: ${uri}`))
  }

  try {
    const hash = toHex(crypto.blake2b(Buffer.from(identifier, 'hex')))
    const path = resolve(rc.network.identity.root, hash, 'ddo.json')
    const ddo = JSON.parse(await pify(fs.readFile)(path))

    if ('id' in ddo && ddo.id === uri) {
      process.stdout.write(ddo.id)
      process.stdout.write('\n')
      process.exit(0)
    } else {
      process.exit(1)
    }
  } catch (err) {
    debug(err)
    process.exit(1)
  }
}

function onfatal(err) {
  debug(err)
  error('fatal:', err.message)
  process.exit(1)
}
