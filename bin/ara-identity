#!/usr/bin/env node

const { info, warn, error } = require('ara-console')
const { writeIdentity } = require('../util')
// const { createCFS } = require('cfsnet/create')
const { resolve } = require('path')
const { toHex } = require('../util')
const { table } = require('table')
const protobuf = require('../protobuf')
const inquirer = require('inquirer')
const context = require('ara-context')()
const program = require('yargs')
const crypto = require('ara-crypto')
// const mirror = require('mirror-folder')
const debug = require('debug')('ara:identity')
const pify = require('pify')
const did = require('did-uri')
const aid = require('../')
// const ram = require('random-access-memory')
const fs = require('fs')
const rc = require('../rc')()
const ss = require('ara-secret-storage')

process.on('unhandledRejection', onfatal)
process.on('uncaughtException', onfatal)

program
  .usage('usage: $0 [-hDV] [options] <command> [options]')
  .wrap(null)

program
  .group([ 'help', 'debug', 'version' ], 'General Options:')
  .option('help', {
    alias: 'h',
    describe: 'Show this help message'
  })
  .option('debug', {
    alias: 'D',
    describe: 'Enable debug output',
  })
  .option('version', {
    alias: 'V',
    describe: 'Show program version'
  })

program.command(
  'create',
  'Create an identity',
  // eslint-disable-next-line no-shadow
  program => program
  , oncreate
)

program.command(
  'archive [did]',
  'Archive identity in network',
  // eslint-disable-next-line no-shadow
  program => program
    .positional('did', {
      default: rc.network.identity.whoami,
    })
    .group([ 'secret', 'keyring', 'network' ], 'Network Options:')
    .option('secret', {
      alias: 's',
      describe: 'Shared secret key for the associated network keys',
      required: true,
      requiresArg: true,
    })
    .option('keyring', {
      alias: 'k',
      default: rc.network.identity.keyring,
      describe: 'Path to Ara network keyring file',
      required: true,
      requiresArg: true,
    })
    .option('network', {
      alias: 'n',
      describe: 'Human readable network name for keys in keyring',
      required: true,
      requiresArg: true,
    })
  , onarchive
)

program.command(
  'resolve [did]',
  'Resolve an identity',
  // eslint-disable-next-line no-shadow
  program => program
    .positional('did', {
      default: rc.network.identity.whoami,
    })
    .group([ 'secret', 'keyring', 'network' ], 'Network Options:')
    .option('secret', {
      alias: 's',
      describe: 'Shared secret key for the associated network keys.',
      requiresArg: true,
    })
    .option('network', {
      alias: 'n',
      describe: 'Human readable network name for keys in keyring',
      requiresArg: true,
    })
    .option('keyring', {
      alias: 'k',
      default: rc.network.identity.keyring,
      describe: 'Path to Ara network keyring file',
      required: true,
      requiresArg: true,
    })
    .group([ 'cache', 'timeout' ], 'Resolution Options:')
    .option('cache', {
      alias: 'C',
      describe: 'Enable or disable cache',
      default: true
    })
    .option('timeout', {
      alias: 't',
      describe: 'Resolution timeout',
    })
  , onresolve
)

program.command(
  'list',
  'Output local identities',
  // eslint-disable-next-line no-shadow
  program => program
    .group([ 'path' ], 'List Options:')
    .option('path', {
      alias: 'p',
      describe: 'Path to look for identities',
      optional: true
    })
  , onlist
)

program.command(
  'whoami',
  'Output current Ara identity in context (.ararc)',
  // eslint-disable-next-line no-shadow
  program => program
  , onwhoami
)

program
  .recommendCommands()
  .completion('completion', false)

void program.getOptions().boolean.splice(-2)

if (0 === program.argv._.length) {
  program.showHelp()
  process.exit(1)
}

if (program.argv.debug) {
  // eslint-disable-next-line global-require
  require('debug').enable('ara:identity*')
}

async function onarchive(argv) {
  if (0 === argv.did.indexOf('did:') && 0 !== argv.did.indexOf('did:ara:')) {
    onfatal(new Error('Expecting a did URI with an \'ara\' method.'))
  }

  if (0 !== argv.did.indexOf('did:ara:')) {
    // eslint-disable-next-line no-param-reassign
    argv.did = `did:ara:${argv.did}`
  }

  let { password } = await inquirer.prompt([ {
    type: 'password',
    name: 'password',
    message:
    'Please provide a passphrase for your identity. This is needed to ' +
    'archive your identity.\n' +
    'Passphrase:'
  } ])

  if (!password) {
    // eslint-disable-next-line function-paren-newline
    onfatal(
      new TypeError('Please provide a password to archive your identity.'))
  }

  password = crypto.blake2b(Buffer.from(password))

  const { identifier } = did.parse(argv.did)
  const hash = toHex(crypto.blake2b(Buffer.from(identifier, 'hex')))
  const path = resolve(rc.network.identity.root, hash)
  const identityBuffer = await pify(fs.readFile)(resolve(path, 'identity'))
  const identity = protobuf.messages.Identity.decode(identityBuffer)

  try {
    const { keyring, network } = argv

    const { secret } = argv
    const keystorePath = resolve(path, 'keystore/ara')
    const keystoreBuffer = await pify(fs.readFile)(keystorePath, 'utf8')
    const keys = JSON.parse(String(keystoreBuffer))
    const secretKey = ss.decrypt(keys, { key: password.slice(0, 16) })
    const publicKey = secretKey.slice(32)
    const { files } = identity

    // manually construct identity file for archiver
    files.push({ path: 'identity', buffer: identityBuffer })
    warn('Archiving new identity for network \'%s\'.', keyring)
    await aid.archive({
      publicKey, secretKey, files
    }, {
      network,
      secret,
      keyring,

      onhello,
      onauth,
      onokay,

      onclose,
      onerror,
    })
  } catch (err) {
    error('Possible incorrect password.')
    onfatal(err)
  }

  function onhello(hello) {
    info(
      'Got hello from archiver node: key=%s mac=%s',
      hello.publicKey.toString('hex'),
      hello.mac.toString('hex'),
    )
  }

  function onauth(auth) {
    info(
      'Authenticated with archiver node: keys=%s signature=%s',
      auth.publicKey.toString('hex'),
      auth.signature.toString('hex'),
    )
  }

  function onokay(okay) {
    info(
      'Got okay from archiver node: signature=%s',
      okay.toString('hex'),
    )
  }

  function onclose() {
    info('Connection closed')
    process.nextTick(() => process.exit(0))
  }

  function onerror(err) {
    debug(err.stack || err)
    error('Got error in archiver:', err.message)
    process.nextTick(() => process.exit(1))
  }
}

async function oncreate() {
  const { password } = await inquirer.prompt([ {
    type: 'password',
    name: 'password',
    message:
    'Your identity\'s keystore will be secured by a passphrase. \n' +
    'Please provide a passphrase. Do not forget this as it will never be ' +
    'shown to you.\n' +
    'Passphrase:'
  } ])

  process.stdout.write('\n')
  const identity = await aid.create({ context, password })

  info('New identity created: %s', identity.did)

  for (let i = 0; i < identity.files.length; ++i) {
    warn('Will write identity file: %s', identity.files[i].path)
  }

  await writeIdentity(identity)

  info('Please safely store the following 12 word mnemonic phrase for this')
  info('Ara ID. This phrase will be required to restore your Ara ID.')
  info('It will never be shown again:')
  info('\n\n%s', table([ [ identity.mnemonic ] ]))

  process.exit(0)
}

async function onresolve(argv) {
  if (!argv.keyring && !argv.cache) {
    onfatal(new TypeError('Expecting Ara network keyring file.'))
  }

  if (!argv.secret && !argv.cache) {
    onfatal(new TypeError('Expecting Shared secret key.'))
  }

  if (!argv.network && !argv.cache) {
    onfatal(new TypeError('Expecting Human readable network keys name.'))
  }

  if (0 === argv.did.indexOf('did:') && 0 !== argv.did.indexOf('did:ara:')) {
    onfatal(new Error('Expecting a did URI with an \'ara\' method.'))
  }

  if (0 !== argv.did.indexOf('did:ara:')) {
    // eslint-disable-next-line no-param-reassign
    argv.did = `did:ara:${argv.did}`
  }

  try {
    const { timeout, secret, network } = argv
    const { keyring } = argv

    let cache

    if (argv['no-cache'] || argv.nocache || false === argv.cache) {
      cache = false
    } else if (true === argv.cache) {
      cache = true
    }

    const identity = await aid.resolve(argv.did, {
      network,
      keyring,
      timeout,
      secret,
      cache,
    })

    process.stdout.write(JSON.stringify(identity))
  } catch (err) {
    onfatal(err)
  }

  process.exit(0)
}

async function onlist(argv) {
  try {
    debug('aid: list: %s', argv.path)

    const identities = await aid.list(argv.path)

    debug('aid: list: %d identities', identities.length)
    for (const id of identities) {
      process.stdout.write(`${id}\n`)
    }

    process.exit(0)
  } catch (err) {
    onfatal(err)
  }
}

async function onwhoami(argv) {
  void argv
  let identifier = null
  let uri = rc.network.identity.whoami

  if (uri && 0 !== uri.indexOf('did:ara:')) {
    // eslint-disable-next-line no-param-reassign
    uri = `did:ara:${uri}`
  }

  if (!uri) {
    process.exit(1)
    return
  }

  try {
    // eslint-disable-next-line prefer-destructuring
    identifier = did.parse(uri).identifier
  } catch (err) {
    onfatal(new Error(`Failed to parse DID URI: ${uri}`))
  }

  try {
    const hash = toHex(crypto.blake2b(Buffer.from(identifier, 'hex')))
    const path = resolve(rc.network.identity.root, hash, 'ddo.json')
    const ddo = JSON.parse(await pify(fs.readFile)(path))

    if ('id' in ddo && ddo.id === uri) {
      process.stdout.write(ddo.id)
      process.stdout.write('\n')
      process.exit(0)
    } else {
      process.exit(1)
    }
  } catch (err) {
    debug(err)
    process.exit(1)
  }
}

function onfatal(err) {
  debug(err)
  error('fatal:', err.message)
  process.exit(1)
}
