#!/usr/bin/env node

const { info, warn, error } = require('ara-console')
const { writeIdentity } = require('../util')
const { resolve } = require('path')
const { toHex } = require('../util')
const { table } = require('table')
const protobuf = require('../protobuf')
const inquirer = require('inquirer')
const context = require('ara-context')()
const program = require('yargs')
const crypto = require('ara-crypto')
const debug = require('debug')('ara:identity')
const pify = require('pify')
const did = require('did-uri')
const aid = require('../')
const rc = require('../rc')()
const ss = require('ara-secret-storage')
const fs = require('fs')

process.on('unhandledRejection', onfatal)
process.on('uncaughtException', onfatal)

const ellipsis = (s, x, y) => s.slice(x || 0, y || 4)

program
  .usage('usage: $0 [-hDV] <command> [options]')
  .wrap(null)

program
  .group([ 'help', 'debug', 'version' ], 'General Options:')
  .option('help', {
    alias: 'h',
    describe: 'Show this help message',
  })
  .option('debug', {
    alias: 'D',
    describe: 'Enable debug output',
  })
  .option('version', {
    alias: 'V',
    describe: 'Show program version'
  })
  .option('quiet', {
    alias: 'q',
    default: false
    describe: 'Only output errors and results'
  })

program.command(
  'create',
  'Create an identity',
  // eslint-disable-next-line no-shadow
  program => program
    .usage('usage: $0 create [-D] [options]')
  , oncreate
)

program.command(
  'archive [did]',
  'Archive identity in network',
  // eslint-disable-next-line no-shadow
  program => program
    .usage('usage: $0 archive [-D] [options]')
    .positional('did', {
      default: rc.network.identity.whoami,
    })
    .group([ 'secret', 'keyring', 'network' ], 'Network Options:')
    .option('secret', {
      alias: 's',
      describe: 'Shared secret key for the associated network keys',
      required: true,
      requiresArg: true,
    })
    .option('keyring', {
      alias: 'k',
      default: rc.network.identity.keyring,
      describe: 'Path to Ara network keyring file',
      required: true,
      requiresArg: true,
    })
    .option('network', {
      alias: 'n',
      describe: 'Human readable network name for keys in keyring',
      required: true,
      requiresArg: true,
    })
  , onarchive
)

program.command(
  'resolve [did]',
  'Resolve an identity',
  // eslint-disable-next-line no-shadow
  program => program
    .usage('usage: $0 resolve [-D] [options]')
    .positional('did', {
      default: rc.network.identity.whoami,
    })
    .group([ 'secret', 'keyring', 'network' ], 'Network Options:')
    .option('secret', {
      alias: 's',
      describe: 'Shared secret key for the associated network keys.',
      requiresArg: true,
    })
    .option('network', {
      alias: 'n',
      describe: 'Human readable network name for keys in keyring',
      requiresArg: true,
    })
    .option('keyring', {
      alias: 'k',
      default: rc.network.identity.keyring,
      describe: 'Path to Ara network keyring file',
      requiresArg: true,
    })
    .group([ 'cache', 'timeout' ], 'Resolution Options:')
    .option('cache', {
      type: 'boolean',
      alias: 'C',
      describe: 'Enable or disable cache',
      default: true,
    })
    .option('timeout', {
      alias: 't',
      describe: 'Resolution timeout',
    })
  , onresolve
)

program.command(
  'list',
  'Output local identities',
  // eslint-disable-next-line no-shadow
  program => program
    .usage('usage: $0 list [-D] [options]')
    .group([ 'path' ], 'List Options:')
    .option('path', {
      alias: 'p',
      describe: 'Path to look for identities',
      optional: true
    })
  , onlist
)

program.command(
  'whoami',
  'Output current Ara identity in context (.ararc)',
  // eslint-disable-next-line no-shadow
  program => program
    .usage('usage: $0 whoami [-D] [options]')
    .group([ 'cache', 'timeout' ], 'Resolution Options:')
    .option('cache', {
      type: 'boolean',
      alias: 'C',
      describe: 'Enable or disable cache',
      default: true,
    })
    .option('timeout', {
      alias: 't',
      describe: 'Resolution timeout',
    })
  , onwhoami
)

program.command(
  'recover',
  'Recover an Ara identity using a mnemonic',
  // eslint-disable-next-line no-shadow
  program => program
    .usage('usage: $0 [-D] recover [options]')
    .group([ 'mnemonic' ], 'Recovery Options:')
    .option('mnemonic', {
      alias: 'm',
      describe: 'Valid bip39 mnemonic',
      required: true,
      requiresArg: true,
    })
  , onrecover
)

program.command(
  'keystore-dump [did] [type]',
  'Recover a private ethereum|ara key.',
  // eslint-disable-next-line no-shadow
  program => program
    .usage('usage: $0 keystore-dump [-D] [options]')
    .positional('did', {
      default: rc.network.identity.whoami,
    })
    .positional('type', {
      default: 'eth',
    })
    .group([ 'path', 'file' ], 'Options:')
    .option('path', {
      alias: 'p',
      describe: 'Path to look for did directory',
      optional: true
    })
  , onkeystoredump
)

program
  .recommendCommands()
  .completion('completion', false)

void program.getOptions().boolean.splice(-2)

if (0 === program.argv._.length) {
  program.showHelp()
  process.exit(1)
}

if (program.argv.debug) {
  // eslint-disable-next-line global-require
  require('debug').enable('ara:identity*')
}

async function onrecover(argv) {
  const { mnemonic } = argv
  let { password } = argv

  if ('string' === typeof password) {
    try {
      await pify(fs.access)(password)
      password = String(await pify(fs.readFile)(password))
    } catch (err) {
      void err
    }
  }

  if (!password) {
    ({ password } = await inquirer.prompt([ {
      type: 'password',
      name: 'password',
      message:
      'Your identity\'s keystore will be secured by a passphrase ' +
      'after recovery. \n' +
      'Please provide a passphrase. Do not forget this as it will never be ' +
      'shown to you.\n' +
      'Passphrase:'
    } ]))
  }

  if (!password) {
    // eslint-disable-next-line function-paren-newline
    onfatal(
      new TypeError('A new passphrase is required to recover the identity.'))
  }

  try {
    const identity = await aid.recover({ context, password, mnemonic })
    info('Identity recovered : %s', identity.did)

    for (let i = 0; i < identity.files.length; ++i) {
      warn('Will write identity file: %s', identity.files[i].path)
    }

    await writeIdentity(identity)
    info('Identity recovered successfully.')
  } catch (err) {
    onfatal(err)
  }

  process.exit(0)
}

async function onarchive(argv) {
  let { password } = argv

  if (0 === argv.did.indexOf('did:') && 0 !== argv.did.indexOf('did:ara:')) {
    onfatal(new Error('Expecting a did URI with an \'ara\' method.'))
  }

  if (0 !== argv.did.indexOf('did:ara:')) {
    // eslint-disable-next-line no-param-reassign
    argv.did = `did:ara:${argv.did}`
  }

  if ('string' === typeof password) {
    try {
      await pify(fs.access)(password)
      password = String(await pify(fs.readFile)(password))
    } catch (err) {
      void err
    }
  }

  if (!password) {
    ({ password } = await inquirer.prompt([ {
      type: 'password',
      name: 'password',
      message:
      'Please provide a passphrase for your identity. This is needed to ' +
      'archive your identity.\n' +
      'Passphrase:'
    } ]))
  }

  if (!password) {
    // eslint-disable-next-line function-paren-newline
    onfatal(
      new TypeError('Please provide a password to archive your identity.'))
  }

  password = crypto.blake2b(Buffer.from(password))

  const { identifier } = did.parse(argv.did)
  let identityBuffer = null
  let identity = null

  const stats = {
    totalConnections: 0
  }

  const { keyring, network, secret } = argv

  let secretKey = null
  let publicKey = null

  try {
    const keystoreBuffer = await aid.fs.readFile(identifier, 'keystore/ara')
    const keystore = JSON.parse(String(keystoreBuffer))

    try {
      secretKey = ss.decrypt(keystore, { key: password.slice(0, 16) })
      publicKey = secretKey.slice(32)
    } catch (err) {
      debug(err)
      onfatal(new Error('Invalid passphrase when decoding keystore.'))
    }

    identityBuffer = await aid.fs.readFile(identifier, 'identity', argv)
  } catch (err) {
    error('Unable to read identity.')
    onfatal(err)
  }

  try {
    identity = protobuf.messages.Identity.decode(identityBuffer)
  } catch (err) {
    error('Failed to decode identity.')
    onfatal(err)
  }

  const { files } = identity

  try {
    // manually construct identity file for archiver
    files.push({
      path: 'identity',
      buffer: identityBuffer
    })

    warn('Archiving new identity for network \'%s\'.', keyring)
    const didArchive = await aid.archive({
      publicKey,
      secretKey,
      files
    }, {
      network,
      secret,
      keyring,

      onhello,
      onauth,
      onokay,

      onclose,
      onerror,
    })

    info(
      '%d connection%s made',
      stats.totalConnections,
      1 === stats.totalConnections ? '' : 's',
    )

    if (didArchive) {
      info('Successfully archived identity to network "%s"', network)
      process.nextTick(() => process.exit(0))
    } else {
      error('Failed to archive identity')
      process.nextTick(() => process.exit(1))
    }
  } catch (err) {
    error('Failed to archive identity.')
    onfatal(err)
  }

  function onhello(hello) {
    info(
      'Got hello from archiver node: key=%s mac=%s',
      toHex(ellipsis(hello.publicKey)),
      toHex(ellipsis(hello.mac)),
    )
  }

  function onauth(auth) {
    info(
      'Authenticated with archiver node: keys=%s signature=%s',
      toHex(ellipsis(auth.publicKey)),
      toHex(ellipsis(auth.signature)),
    )
  }

  function onokay(okay) {
    info(
      'Got okay from archiver node: signature=%s',
      toHex(ellipsis(okay)),
    )
  }

  function onclose(rinfo) {
    stats.totalConnections = rinfo.totalConnections
    debug(
      'Connection #%d to %s:%s@%s closed.',
      rinfo.peerIndex,
      rinfo.peer.host,
      rinfo.peer.port,
      toHex(ellipsis(rinfo.discoveryKey)),
    )
  }

  function onerror(err) {
    debug(err.stack || err)
    error('Got error in archiver:', err.message)
    process.nextTick(() => process.exit(1))
  }
}

async function oncreate(argv) {
  let { password } = argv

  if ('string' === typeof password) {
    try {
      await pify(fs.access)(password)
      password = String(await pify(fs.readFile)(password))
    } catch (err) {
      void err
    }
  }

  if (!password) {
    ({ password } = await inquirer.prompt([ {
      type: 'password',
      name: 'password',
      message:
      'Your identity\'s keystore will be secured by a passphrase. \n' +
      'Please provide a passphrase. Do not forget this as it will never be ' +
      'shown to you.\n' +
      'Passphrase:'
    } ]))
  }

  if (!password) {
    // eslint-disable-next-line function-paren-newline
    onfatal(
      new TypeError('A new passphrase is required to secure the identity.'))
  }

  !argv.quiet && process.stdout.write('\n')
  const identity = await aid.create({ context, password })

  !argv.quiet && info('New identity created: %s', identity.did)

  for (let i = 0; i < identity.files.length; ++i) {
    argv.quiet && warn('Will write identity file: %s', identity.files[i].path)
  }

  await writeIdentity(identity)

  !argv.quiet && info('Please safely store the following 12 word mnemonic phrase for this')
  !argv.quiet && info('Ara ID. This phrase will be required to restore your Ara ID.')
  !argv.quiet && info('It will never be shown again:')
  !argv.quiet && info('\n\n%s', table([ [ identity.mnemonic ] ]))
  argv.quiet && process.stdout.write(identity.mnemonic + "\n")

  process.exit(0)
}

async function onresolve(argv) {
  if (!argv.keyring && !argv.cache) {
    onfatal(new TypeError('Expecting Ara network keyring file.'))
  }

  if (!argv.secret && !argv.cache) {
    onfatal(new TypeError('Expecting Shared secret key.'))
  }

  if (!argv.network && !argv.cache) {
    onfatal(new TypeError('Expecting Human readable network keys name.'))
  }

  if (0 === argv.did.indexOf('did:') && 0 !== argv.did.indexOf('did:ara:')) {
    onfatal(new Error('Expecting a did URI with an \'ara\' method.'))
  }

  if (0 !== argv.did.indexOf('did:ara:')) {
    // eslint-disable-next-line no-param-reassign
    argv.did = `did:ara:${argv.did}`
  }

  try {
    let cache

    const {
      timeout,
      keyring,
      network,
      secret,
    } = argv

    if (argv['no-cache'] || argv.nocache || false === argv.cache) {
      cache = false
    } else if (true === argv.cache) {
      cache = true
    }

    const identity = await aid.resolve(argv.did, {
      network,
      keyring,
      timeout,
      secret,
      cache,
    })

    process.stdout.write(JSON.stringify(identity))
  } catch (err) {
    onfatal(err)
  }

  process.exit(0)
}

async function onlist(argv) {
  try {
    debug('aid: list: %s', argv.path)

    const identities = await aid.list(argv.path)

    debug('aid: list: %d identities', identities.length)
    for (const id of identities) {
      process.stdout.write(`${id}\n`)
    }

    process.exit(0)
  } catch (err) {
    onfatal(err)
  }
}

async function onwhoami(argv) {
  let identifier = rc.network.identity.whoami
  let ddo = null

  if (identifier && 0 !== identifier.indexOf('did:ara:')) {
    // eslint-disable-next-line no-param-reassign
    identifier = `did:ara:${identifier}`
  }

  if (!identifier) {
    process.exit(1)
    return
  }

  try {
    ddo = JSON.parse(await aid.fs.readFile(identifier, 'ddo.json', argv))
  } catch (err) {
    try {
      ddo = await aid.resolve(identifier, argv)
      if (!ddo) {
        throw err
      }
    } catch (err2) {
      debug(err2)
      onfatal(err)
    }
  }

  if (!ddo) {
    onfatal(new Error('Missing or malformed identity document (ddo.json).'))
  }

  if ('id' in ddo && ddo.id === identifier) {
    process.stdout.write(ddo.id)
    process.stdout.write('\n')
    process.exit(0)
  } else {
    process.exit(1)
  }
}

async function onkeystoredump(argv) {
  const identity = aid.did.getIdentifier(argv.did)
  const hash = toHex(crypto.blake2b(Buffer.from(identity, 'hex')))
  let path = identity.path
  if (undefined === path) {
    // eslint-disable-next-line no-param-reassign
    path = resolve(rc.network.identity.root, hash, 'keystore')
  }

  try {
    await pify(fs.readdir)(path)
  } catch (err) {
    throw new Error(`Cannot read identity 'did:ara:${identity}'. ${err}`)
  }

  const { password } = await inquirer.prompt([ {
    type: 'password',
    name: 'password',
    message:
    'Please enter the passphrase associated with the identity. \n' +
    'Passphrase:'
  } ])

  process.stdout.write('\n')

  const keystores = []
  const visits = []

  const araPath = resolve(path, 'ara')
  const ethPath = resolve(path, 'eth')
  const ara = await pify(visit)(araPath)
  const eth = await pify(visit)(ethPath)

  function visit(entry, cb) {
    const file = resolve(entry)
    fs.access(file, onaccess)
    function onaccess(err) {
      if (null === err) {
        fs.readFile(file, onread)
      } else {
        cb(null)
      }
    }

    function onread(err, buf) {
      if (err) {
        cb(err)
      } else {
        try {
          if ('undefined' !== typeof buf) {
            keystores.push(buf)
          }

          cb(null)
        } catch (err2) {
          debug('keystore dump: visit: onread: error:', err2)
          cb(null)
        }
      }
    }
  }

  if ('ara' === argv.type) {
    let secretKey
    const keystore = JSON.parse(String(keystores[0]))

    try {
      const passwordBuffer = crypto.blake2b(Buffer.from(password))
      secretKey = ss.decrypt(keystore, { key: passwordBuffer.slice(0, 16) })
      const publicKey = secretKey.slice(32)
    } catch (err) {
      debug(err)
      onfatal(new Error('Invalid passphrase when decoding ara keystore.'))
    }

    info('Ara private key: %s', toHex(secretKey))
  } else { // Print Ethereum private Key
    const privateKey = await aid
      .ethereum
      .keystore
      .recover(password, keystores[0], keystores[1])

    info('Ara ID Ethereum private key: %s', toHex(privateKey))
  }

  process.exit(0)
}

function onfatal(err) {
  debug(err)
  error('fatal:', err.message)
  process.exit(1)
}
